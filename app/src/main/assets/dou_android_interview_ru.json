[
  {
    "levelTitle": "Junior",
    "questions": [
      {
        "topic": "Базові питання",
        "questions": [
          {
            "questionText": "Назвіть основні принципи ООП",
            "answerItems": [
              "Инкапсуляция: Скрытие деталей реализации (модификатор доступа private). \n- Безопасность данных от внешнего изменения;\n- Уменьшает сложность программы.",
              "Наследование: Переиспользование protected полей и методов класса в наследнике (ключевое слово extends). Уменьшаем количество кода посредством его повторного использования.",
              "Полиморфизм: Когда требуемое поведение (описанное в interface) реализуется разными классами без информации о самих классах, что позволяет на лету изменять поведение программы",
              "Абстракция: Позволяет сконцентрироваться на важном, игнорируя несущественное. \n- abstract class НЕ позволит создать объект (только наслодоваться, причем только от 1 абстрактного класса, нельзя сразу от 2);\n- abstract method НЕ может иметь тело;\n- abstract val НЕ может быть инициализирован при объявлении"
            ]
          },
          {
            "questionText": "Що таке class? Що таке interface? Яка між ними різниця?",
            "answerItems": [
              "Класс: Шаблон для создания объектов, содержащий их состояние (поля) и поведение (методы).",
              "Интерфейс: Инструмент для определения поведения (названий методов), которое должны реализовывать классы",
              "Различие: Классы представляют собой конкретную реализацию (инициализированные поля, методы с телами), в то время как интерфейсы определяют только структуру поведения ."
            ]
          },
          {
            "questionText": "Яка різниця між abstract class та interface?",
            "answerItems": [
              "Абстрактный класс: \n- МОЖЕТ иметь конструктор;\n- По дефолту методы public;\n- Можно использовать private/protected/internal и описать тело или abstract БЕЗ тела;\n- Та же история с переменными;\n- Класс может унаследовать ТОЛЬКО 1 абстрактный класс;",
              "Интерфейс:\n- НЕ может иметь конструктор;\n- По дефолту методы abstract public (protected запрещены);\n- Приватному методу можно описать тело;\n- По дефолту поля public static final;\n- Можно объявить переменные, но НЕЛЬЗЯ их инициализировать (даже приватную);\n- Класс может одновременно реализовывать много интерфейсов;",
              "Основное различие заключается в том, что абстрактные классы могут хранить состояние (поля), в то время как интерфейсы не могут."
            ]
          },
          {
            "questionText": "Назвіть базові типи даних.",
            "answerItems": [
              "Целочисленные типы: int, short, long, byte, представляют целые числа различной длины.",
              "Типы с плавающей точкой: float, double, используются для представления чисел с дробной частью.",
              "Символьный тип: char, представляет отдельные символы.",
              "Логический тип: boolean, представляет истину или ложь (true/false)."
            ]
          },
          {
            "questionText": "Назвіть модифікатори доступу в Java.",
            "answerItems": [
              "private: Видно в пределах данного класса",
              "default (package visible): Видно ТОЛЬКО пределах package",
              "protected: Видно в пределах package И ЛЮБЫМ наследникам",
              "public: Видно всем"
            ]
          },
          {
            "questionText": "Назвіть модифікатори доступу в Kotlin.",
            "answerItems": [
              "private: \n- Видно в пределах данного класса/интерфейса/файла .kt \n- Переменные внутри методов всегда private; \n- class C private constructor(a: Int) { ... }",
              "protected: \n- Как private + видимость в наследниках;\n- Запрещено использовать в объявлениях \"высокого уровня\". Чтобы использовать видимое объявление верхнего уровня из другого пакета, нужно импортировать его (import).\n",
              "internal (module visible): Видно в пределах Gradle/Maven модуля",
              "public (default in Kotlin): Видно из космоса!"
            ]
          },
          {
            "questionText": "У чому відмінність примітивних типів від об’єктів?",
            "answerItems": [
              "Примитивные типы (например, int, float) представляют простые значения и хранятся непосредственно в памяти.",
              "Объекты являются экземплярами классов и содержат более сложные структуры данных, предоставляя методы и свойства.",
              "Примитивы обычно занимают меньше памяти и обрабатываются быстрее, в то время как объекты предоставляют большую гибкость и функциональность."
            ]
          },
          {
            "questionText": "Що таке патерни проєктування? Які патерни ви знаєте?",
            "answerItems": [
              "Паттерны проектирования - это проверенные решения для часто встречающихся проблем в программировании.",
              "Примеры паттернов: Singleton (одиночка), Observer (наблюдатель), Factory (фабрика), Strategy (стратегия).",
              "Каждый паттерн описывает сценарий, в котором он наиболее эффективен, и предлагает определённый способ структурирования кода."
            ]
          },
          {
            "questionText": "Чим відрізняється Java від Kotlin?",
            "answerItems": [
              "Java - это более старый язык программирования с более строгим и вербозным синтаксисом.",
              "Kotlin - современный язык, который предоставляет более краткий синтаксис и дополнительные функции, такие как null safety и extension functions.",
              "Kotlin полностью совместим с Java и может использоваться вместе с Java в одном проекте. Он также обеспечивает более удобную поддержку функционального программирования."
            ]
          }
        ]
      },
      {
        "topic": "Алгоритми",
        "questions": [
          {
            "questionText": "Що таке алгоритм і як вибрати правильний?",
            "answerItems": [
              "Алгоритм - это чётко определённая последовательность шагов или правил для решения задачи или выполнения задания.",
              "Выбор алгоритма зависит от множества факторов, включая требования к производительности, объём и тип данных, ограничения по памяти и время выполнения.",
              "Важно учитывать сложность алгоритма (время и память), его устойчивость к ошибкам и простоту реализации."
            ]
          },
          {
            "questionText": "Що таке складність алгоритму? Як і за допомогою чого її можна вирахувати?",
            "answerItems": [
              "Сложность алгоритма - это мера оценки времени выполнения и объёма занимаемой памяти алгоритмом.",
              "Вычисляется с помощью теоретического анализа алгоритма, чаще всего используется нотация Big O для описания временной сложности.",
              "Также учитывается пространственная сложность, которая описывает объём памяти, необходимый для выполнения алгоритма."
            ]
          },
          {
            "questionText": "Що таке нотація big-O?",
            "answerItems": [
              "Нотация Big O - математическая нотация, используемая для описания верхней границы сложности алгоритма.",
              "Она описывает худший сценарий выполнения алгоритма с точки зрения времени или занимаемой памяти.",
              "Например, O(n) означает, что время выполнения пропорционально размеру входных данных."
            ]
          },
          {
            "questionText": "Що таке рекурсія?",
            "answerItems": [
              "Рекурсия - это подход в программировании, при котором функция вызывает сама себя.",
              "Она используется для решения задач, которые могут быть разбиты на более мелкие, идентичные задачи.",
              "Важно правильно определить условие выхода из рекурсии, чтобы избежать бесконечного цикла.",
              "Рекурсия часто применяется в алгоритмах обхода деревьев, вычисления факториалов, Фибоначчи и других математических последовательностей."
            ]
          },
          {
            "questionText": "Які алгоритми сортування ви знаєте?",
            "answerItems": [
              "Сортировка пузырьком: Простой, но медленный алгоритм, который повторно проходит по списку, меняя местами элементы, если они находятся в неправильном порядке.",
              "Быстрая сортировка (Quick Sort): Один из самых эффективных методов сортировки на практике, использует стратегию 'разделяй и властвуй'.",
              "Сортировка слиянием (Merge Sort): Также использует подход 'разделяй и властвуй', эффективен для больших наборов данных.",
              "Сортировка вставками (Insertion Sort): Эффективна для небольших массивов или частично отсортированных массивов.",
              "Сортировка выбором (Selection Sort): Находит минимальный элемент и помещает его в начало массива, повторяя процесс для остальной части массива."
            ]
          }
        ]
      },
      {
        "topic": "Структури даних",
        "questions": [
          {
            "questionText": "Розкажіть про такі структури даних, як List, Set, Map?",
            "answerItems": [
              "List: Упорядкованная коллекция, которая может содержать дублирующиеся элементы. Поддерживает доступ к элементам по индексу.",
              "Set: Набор уникальных элементов. Не поддерживает порядок и дублирование элементов.",
              "Map: Коллекция пар 'ключ-значение'. Каждый ключ уникален, и каждому ключу соответствует одно значение."
            ]
          },
          {
            "questionText": "Яка різниця між ArrayList та LinkedList?",
            "answerItems": [
              "ArrayList: Основан на массиве. Обеспечивает быстрый доступ к элементам по индексу. Добавление или удаление элементов может быть медленным, так как требует сдвига элементов.",
              "LinkedList: Основан на двусвязном списке. Добавление и удаление элементов обычно быстрее, но доступ к элементам по индексу медленнее, так как требует последовательного обхода списка."
            ]
          }
        ]
      },
      {
        "topic": "Зберігання даних",
        "questions": [
          {
            "questionText": "Як можна зберігати дані в Android?",
            "answerItems": [
              "SharedPreferences: Для хранения небольших объемов данных в формате ключ-значение.",
              "SQLite: Встраиваемая база данных для хранения структурированных данных.",
              "Файлы: Запись данных в файлы во внутренней или внешней памяти устройства.",
              "Content Providers: Для обмена данными между приложениями."
            ]
          },
          {
            "questionText": "Коли варто використовувати SharedPreferences?",
            "answerItems": [
              "Для хранения пользовательских настроек или небольших объемов данных, таких как логин, пароль или настройки приложения.",
              "Когда нужен простой механизм чтения и записи данных без необходимости сложного запроса или обработки.",
              "Не рекомендуется для хранения больших или сложных структур данных."
            ]
          },
          {
            "questionText": "З яких компонентів складається бібліотека Room?",
            "answerItems": [
              "Entity: Представляет таблицу в базе данных.",
              "DAO (Data Access Object): Интерфейс для определения методов доступа к данным (вставка, чтение, обновление, удаление).",
              "Database: Абстрактный класс, который содержит базу данных и служит точкой доступа к данным приложения."
            ]
          },
          {
            "questionText": "Що таке @PrimaryKey, @Ignore, @Embedded, @TypeConverters в Room?",
            "answerItems": [
              "@PrimaryKey: Указывает, что поле является первичным ключом в таблице.",
              "@Ignore: Исключает поле или метод из базы данных Room.",
              "@Embedded: Позволяет внедрить поля другого объекта как если бы они были частью текущего объекта.",
              "@TypeConverters: Преобразует типы данных, которые Room не может хранить напрямую, например, даты."
            ]
          },
          {
            "questionText": "Для чого потрібна міграція в базах даних?",
            "answerItems": [
              "Миграция необходима для обновления схемы базы данных без потери существующих данных.",
              "Используется при добавлении, удалении или изменении столбцов таблиц, создании новых таблиц или при изменении отношений между данными.",
              "Позволяет приложению работать с обновленной структурой данных после изменений в базе данных."
            ]
          }
        ]
      },
      {
        "topic": "Робота з мережею",
        "questions": [
          {
            "questionText": "Що таке JSON, XML?",
            "answerItems": [
              "JSON (JavaScript Object Notation): Легковесный формат обмена данными. Основан на нотации объектов JavaScript. Легко читаем для человека и машин.",
              "XML (eXtensible Markup Language): Формат для описания иерархически структурированных данных. Поддерживает пользовательские теги, атрибуты и иерархию."
            ]
          },
          {
            "questionText": "Які є варіанти реалізації роботи із сервером?",
            "answerItems": [
              "HTTP запросы: Прямые запросы к серверу через HTTP протокол, используя методы как GET, POST, PUT, DELETE.",
              "Web Services: Использование SOAP или RESTful веб-сервисов для обмена данными.",
              "WebSocket: Для постоянного соединения с сервером и двусторонней связи в реальном времени.",
              "GraphQL: Язык запросов для API, позволяющий клиенту точно указать, какие данные ему нужны."
            ]
          },
          {
            "questionText": "Що таке REST?",
            "answerItems": [
              "REST (Representational State Transfer): Архитектурный стиль разработки веб-сервисов, основанный на стандартных HTTP запросах.",
              "Поддерживает операции CRUD (создание, чтение, обновление, удаление) через HTTP методы (GET, POST, PUT, DELETE).",
              "Не сохраняет состояние клиента между запросами, что делает его более масштабируемым и простым для использования."
            ]
          }
        ]
      },
      {
        "topic": "Багатопотоковість",
        "questions": [
          {
            "questionText": "Що таке процес?",
            "answerItems": [
              "Процес - это экземпляр выполняемой программы, который содержит свой собственный адресный пространство памяти.",
              "Каждый процес изолирован от других процессов, имеет собственные ресурсы и состояние."
            ]
          },
          {
            "questionText": "Що таке потік?",
            "answerItems": [
              "Поток (thread) - это единица выполнения в рамках процесса.",
              "Потоки в одном процессе могут выполнять разные задачи параллельно, разделяя ресурсы и память процесса."
            ]
          },
          {
            "questionText": "Для чого використовують ключове слово synchronized?",
            "answerItems": [
              "Ключевое слово 'synchronized' используется для обеспечения синхронизации доступа к ресурсам в многопоточной среде.",
              "Оно гарантирует, что только один поток одновременно может выполнять блок кода или метод, помеченный как 'synchronized'."
            ]
          },
          {
            "questionText": "Навіщо синхронізувати потоки?",
            "answerItems": [
              "Синхронизация потоков необходима для предотвращения проблем согласованности данных, таких как гонки за данные и условия гонки.",
              "Это помогает поддерживать целостность и корректное состояние общих ресурсов при их использовании несколькими потоками."
            ]
          },
          {
            "questionText": "Яка різниця між синхронним і асинхронним виконанням?",
            "answerItems": [
              "Синхронное выполнение подразумевает, что задачи выполняются последовательно, одна за другой.",
              "Асинхронное выполнение позволяет задачам выполняться параллельно, не блокируя выполнение других задач."
            ]
          },
          {
            "questionText": "Як ми можемо створити потік у Java?",
            "answerItems": [
              "Создание потока в Java может быть выполнено путем расширения класса 'Thread' или реализации интерфейса 'Runnable'.",
              "После создания объекта 'Thread', можно вызвать метод 'start()', чтобы начать выполнение потока."
            ]
          },
          {
            "questionText": "Що таке deadlock?",
            "answerItems": [
              "Deadlock - это ситуация в многопоточной программе, когда два или более потоков блокируют друг друга, ожидая освобождения ресурсов.",
              "Каждый из потоков ждет, пока другой освободит ресурс, в результате чего они все остаются заблокированными бесконечно."
            ]
          },
          {
            "questionText": "Які варіанти реалізації багатопотоковості є в Android?",
            "answerItems": [
              "Handler и Looper для управления потоками и сообщениями в пользовательском интерфейсе.",
              "AsyncTask для выполнения фоновых операций и обновления пользовательского интерфейса.",
              "ExecutorService для управления пулом потоков."
            ]
          },
          {
            "questionText": "Що таке main thread? Які операції потрібно виконувати на main thread, які не можна виконувати?",
            "answerItems": [
              "Main thread - это основной поток в Android, отвечающий за обновление пользовательского интерфейса и обработку событий интерфейса.",
              "На main thread следует выполнять короткие задачи и обновления интерфейса. Длительные или трудоемкие операции следует выполнять в фоновых потоках, чтобы избежать 'зависания' интерфейса."
            ]
          }
        ]
      },
      {
        "topic": "Java Core",
        "questions": [
          {
            "questionText": "Що таке Exceptions? Навіщо вони потрібні?",
            "answerItems": [
              "Exceptions в Java - механизм для обработки ошибок и других исключительных ситуаций во время выполнения программы.",
              "Они помогают управлять ошибками, предотвращая сбои программы и позволяя выполнить корректное восстановление после ошибок."
            ]
          },
          {
            "questionText": "Навіщо використовують ключові слова final, finally та finalize?",
            "answerItems": [
              "'final' используется для определения констант, запрета наследования классов и запрета переопределения методов.",
              "'finally' - блок кода, который выполняется после блока try-catch, независимо от того, было ли исключение.",
              "'finalize' - метод, вызываемый перед сборкой мусора для выполнения финализации объекта."
            ]
          },
          {
            "questionText": "Що таке абстрактний клас? Що таке інтерфейс?",
            "answerItems": [
              "Абстрактный класс - это класс, который не может быть инстанциирован напрямую и может содержать абстрактные методы (без реализации).",
              "Интерфейс - это контракт или шаблон, который классы могут реализовать, обычно содержит только абстрактные методы."
            ]
          },
          {
            "questionText": "Що таке анонімний клас? Чи використовували на практиці? Для чого?",
            "answerItems": [
              "Анонимный класс - это класс, объявленный и инстанциированный в одном выражении. Обычно используется для создания реализаций интерфейсов или наследования классов на лету.",
              "Они полезны для создания простых реализаций интерфейсов или классов без необходимости формального объявления нового подкласса."
            ]
          },
          {
            "questionText": "Що таке статичний клас (static class)?",
            "answerItems": [
              "Статический класс - это класс, который объявлен внутри другого класса с модификатором static. Он не имеет доступа к нестатическим членам внешнего класса.",
              "Статические классы обычно используются для группировки классов, которые логически связаны с внешним классом."
            ]
          },
          {
            "questionText": "Що таке enum? Для чого його використовують?",
            "answerItems": [
              "Enum (перечисление) - это специальный тип класса в Java, который служит для определения группы констант.",
              "Используется для представления фиксированного набора констант (например, дней недели, месяцев, направлений и т.д.)."
            ]
          },
          {
            "questionText": "Чи можемо ми зробити конструктор приватним?",
            "answerItems": [
              "Да, в Java можно создать приватный конструктор. Это часто используется в паттерне 'Singleton', чтобы предотвратить создание более одного экземпляра класса."
            ]
          },
          {
            "questionText": "Яка різниця між ключовими словами throw та throws?",
            "answerItems": [
              "'throw' используется для явного выброса исключения в методе.",
              "'throws' указывает на то, что метод может вызвать исключение, и это исключение должно быть обработано или объявлено в сигнатуре метода."
            ]
          },
          {
            "questionText": "Яка різниця між Error та Exception?",
            "answerItems": [
              "'Error' указывает на серьезные проблемы, которые приложение не должно пытаться обрабатывать, обычно связанные с средой выполнения.",
              "'Exception' указывает на условия, которые приложение может попытаться обработать."
            ]
          },
          {
            "questionText": "Яка різниця між checked та unchecked exception?",
            "answerItems": [
              "Checked exceptions - исключения, от которых нельзя восстановиться во время выполнения программы, и они должны быть объявлены в сигнатуре метода.",
              "Unchecked exceptions - ошибки во время выполнения (runtime errors), которые можно было бы избежать перед выполнением."
            ]
          },
          {
            "questionText": "Який має виконуватись контракт при перевизначенні equals()?",
            "answerItems": [
              "Симметричность: если a.equals(b) == true, то b.equals(a) должно быть тоже true.",
              "Рефлексивность: для любого ненулевого ссылочного значения a, a.equals(a) должно возвращать true.",
              "Транзитивность: если a.equals(b) == true и b.equals(c) == true, то a.equals(c) должно быть тоже true.",
              "Консистентность: повторные вызовы a.equals(b) должны возвращать одно и то же значение при неизменных a и b."
            ]
          },
          {
            "questionText": "У чому різниця між map() і flatMap() в RxJava?",
            "answerItems": [
              "map(): Трансформирует элементы потока одного типа в элементы другого типа.",
              "flatMap(): Используется для трансформации каждого элемента потока в другой поток, а затем 'сглаживает' эти потоки в один поток."
            ]
          },
          {
            "questionText": "Коли використовуєте observeOn() і коли subscribeOn()?",
            "answerItems": [
              "observeOn(): Изменяет поток, в котором наблюдатели получают уведомления от Observable.",
              "subscribeOn(): Указывает поток, в котором Observable будет выполнять свою работу и отправлять результаты."
            ]
          },
          {
            "questionText": "Як можна обробити помилки в RxJava?",
            "answerItems": [
              "Использование операторов, таких как 'onErrorResumeNext', 'onErrorReturn', 'onExceptionResumeNext', для обработки или перехвата ошибок в потоке.",
              "Применение try-catch блоков внутри лямбда-выражений или методов, вызываемых в потоках."
            ]
          }
        ]
      },
      {
        "topic": "RxJava",
        "questions": [
          {
            "questionText": "У чому різниця між map() і flatMap() в RxJava?",
            "answerItems": [
              "map(): Преобразует элементы, испускаемые Observable, используя функцию преобразования. Этот метод обрабатывает каждый элемент и преобразует его в новый элемент (например, умножение каждого числа на 2).",
              "flatMap(): Преобразует каждый элемент в Observable, который может испускать несколько элементов. Это используется для создания эффекта 'один ко многим', где каждый исходный элемент преобразуется в набор новых элементов."
            ]
          },
          {
            "questionText": "Коли використовуєте observeOn() і коли subscribeOn()?",
            "answerItems": [
              "subscribeOn(): Определяет поток, в котором Observable будет выполнять свою работу (например, сетевой запрос). Это влияет на поток, в котором происходят все операции в цепочке Observable до момента его подписки.",
              "observeOn(): Изменяет поток, в котором наблюдатели получают уведомления от Observable. Это можно использовать для изменения потока, в котором будет выполняться код в операторах, таких как 'map' или 'flatMap', и в функциях обратного вызова подписчиков."
            ]
          },
          {
            "questionText": "Як можна обробити помилки в RxJava?",
            "answerItems": [
              "Использование 'onErrorResumeNext()': Перенаправляет поток ошибок на другой Observable.",
              "Использование 'onErrorReturn()': Возвращает определенное значение в случае ошибки.",
              "Использование 'retry()': Повторно подписывается на Observable при возникновении ошибки.",
              "'try-catch' внутри лямбда-выражений: Обрабатывает исключения внутри блоков кода Observable."
            ]
          },
          {
            "questionText": "Які schedulers знаєте в RxJava? Назвіть їхні відмінності.",
            "answerItems": [
              "Schedulers.io(): Используется для операций ввода-вывода, таких как чтение файла, сетевые запросы. Оптимизирован для операций, которые обычно ожидают завершения (blocking operations).",
              "Schedulers.computation(): Предназначен для CPU-интенсивных задач, таких как обработка данных и вычислений.",
              "Schedulers.newThread(): Создает новый поток для каждой задачи.",
              "Schedulers.single(): Использует один и тот же поток для всех задач.",
              "AndroidSchedulers.mainThread(): Используется в Android для выполнения работы в главном потоке пользовательского интерфейса."
            ]
          },
          {
            "questionText": "Що таке Disposable? Для чого його використовують?",
            "answerItems": [
              "Disposable - это интерфейс в RxJava, который представляет собой ресурс, который можно отменить или закрыть.",
              "Используется для управления подписками в RxJava, позволяя прервать подписку и освободить ресурсы, чтобы предотвратить утечки памяти, особенно в Android."
            ]
          },
          {
            "questionText": "У чому різниця між Hot і Cold Observables? Назвіть приклади в RxJava.",
            "answerItems": [
              "Cold Observables: Начинают испускать данные только после того, как на них подписывается Observer, и данные генерируются заново для каждого подписчика. Примеры: 'Observable.just()', 'Observable.fromIterable()'.",
              "Hot Observables: Начинают испускать данные независимо от наличия подписчиков, данные не генерируются заново для каждого нового подписчика. Примеры: 'ConnectableObservable' и 'Subjects'."
            ]
          }
        ]
      },
      {
        "topic": "Android SDK",
        "questions": [
          {
            "questionText": "Які базові Android-компоненти можете назвати?",
            "answerItems": [
              "Activity: Компонент приложения, представляющий один экран с пользовательским интерфейсом.",
              "Service: Компонент, выполняющий длительные операции в фоновом режиме без пользовательского интерфейса.",
              "Broadcast Receiver: Компонент, который позволяет приложениям получать и реагировать на широковещательные сообщения.",
              "Content Provider: Компонент для управления доступом к централизованным наборам данных."
            ]
          },
          {
            "questionText": "Що таке ContentProvider?",
            "answerItems": [
              "ContentProvider - Room и ContentProvider решают разные задачи и не зависят друг от друга. Room предоставляет удобный интерфейс для работы с базой данных внутри одного приложения, в то время как ContentProvider предоставляет интерфейс для обмена данными между разными приложениями.",
              "Обычно используется для управления доступом к данным, хранящимся в SQLite базе данных, файловой системе, вебе или других постоянных хранилищах."
            ]
          },
          {
            "questionText": "Які типи Service знаєте?",
            "answerItems": [
              "Started Service: Сервис, который выполняет одноразовую операцию и не возвращает результат вызывающему компоненту.",
              "Bound Service: Сервис, который предоставляет клиент-серверный интерфейс, позволяя компонентам взаимодействовать с сервисом, отправлять запросы и получать результаты."
            ]
          },
          {
            "questionText": "Що таке BroadcastReceiver і які є типи?",
            "answerItems": [
              "BroadcastReceiver - это компонент Android, который позволяет приложениям получать и обрабатывать широковещательные сообщения от Android системы или других приложений.",
              "Типы: Нормальные (обычные) и Упорядоченные (ordered) BroadcastReceiver. Упорядоченные позволяют контролировать порядок обработки сообщений."
            ]
          },
          {
            "questionText": "Для чого використовують механізм фрагментів?",
            "answerItems": [
              "Фрагменты используются для создания гибких и адаптивных пользовательских интерфейсов.",
              "Они представляют поведение или часть пользовательского интерфейса в Activity.",
              "Фрагменты упрощают повторное использование компонентов в разных макетах и адаптацию интерфейса для различных размеров экранов."
            ]
          },
          {
            "questionText": "Опишіть життєвий цикл Activity.",
            "answerItems": [
              "onCreate(): Вызывается при создании Activity.",
              "onStart(): Вызывается, когда Activity становится видимой для пользователя.",
              "onResume(): Вызывается перед тем, как Activity начинает взаимодействовать с пользователем.",
              "onPause(): Вызывается, когда текущее Activity уходит на второй план.",
              "onStop(): Вызывается, когда Activity больше не видно пользователю.",
              "onDestroy(): Вызывается перед тем, как Activity будет уничтожено."
            ]
          },
          {
            "questionText": "Опишіть життєвий цикл Fragment.",
            "answerItems": [
              "onAttach(): Когда фрагмент связывается с Activity.",
              "onCreate(): Создание фрагмента.",
              "onCreateView(): Создание макета для фрагмента.",
              "onActivityCreated(): Activity, содержащая фрагмент, была полностью создана.",
              "onStart(): Фрагмент становится видимым.",
              "onResume(): Фрагмент возвращается в интерактивное состояние.",
              "onPause(): Фрагмент входит в состояние паузы.",
              "onStop(): Фрагмент больше не виден пользователю.",
              "onDestroyView(): Удаление макета фрагмента.",
              "onDestroy(): Уничтожение фрагмента.",
              "onDetach(): Фрагмент отсоединяется от Activity."
            ]
          },
          {
            "questionText": "Чи є у Fragment контекст? Якщо так, то як його отримати?",
            "answerItems": [
              "Да, фрагмент имеет доступ к контексту. Его можно получить через getActivity(), который возвращает Activity, к которой фрагмент прикреплен, или через getContext(), который возвращает контекст фрагмента."
            ]
          },
          {
            "questionText": "Чим відрізняється Fragment від Activity? Навіщо придумали Fragment?",
            "answerItems": [
              "Fragment представляет собой модульный сегмент интерфейса, который может быть встроен в Activity. Он обладает собственным жизненным циклом, получает собственные входящие события и может быть добавлен или удален, в то время как Activity представляет собой один экран или окно в приложении.",
              "Фрагменты были введены для обеспечения большей гибкости в проектировании интерфейсов, особенно для адаптации к различным размерам экранов, таким как планшеты и смартфоны."
            ]
          },
          {
            "questionText": "Що таке зміна конфігурації? Що стається із застосунком на Android при цьому?",
            "answerItems": [
              "Изменение конфигурации - это событие, которое происходит, когда изменяется конфигурация устройства, например, при смене ориентации экрана или языка.",
              "При изменении конфигурации Android обычно пересоздает Activity, чтобы оно могло адаптироваться к новым параметрам. Это включает вызовы методов жизненного цикла, таких как onDestroy() и onCreate()."
            ]
          },
          {
            "questionText": "Що таке Intent? Що таке explicit/implicit Intent?",
            "answerItems": [
              "Intent в Android - это механизм для описания одной операции или действия. Он может использоваться для запуска Activity, Service или отправки сообщений между компонентами.",
              "Explicit Intent указывает непосредственно на компонент, который должен реагировать на intent (например, запуск определенной Activity).",
              "Implicit Intent не указывает прямо на компонент, но описывает общее действие, которое должно быть выполнено, позволяя системе найти подходящий компонент."
            ]
          },
          {
            "questionText": "Що таке SharedPreferences?",
            "answerItems": [
              "SharedPreferences в Android - это механизм для хранения и получения пар ключ-значение, используемый для хранения легковесных данных.",
              "Используется для сохранения пользовательских настроек или другой небольшой информации, как логины или настройки."
            ]
          },
          {
            "questionText": "Що таке ANR? Як уникати таких ситуацій?",
            "answerItems": [
              "ANR (Application Not Responding) - это диалоговое окно, которое появляется, когда приложение не отвечает на ввод пользователя или занимает слишком много времени для обработки.",
              "Чтобы избежать ANR, важно выполнять длительные операции (как сетевые запросы) в фоновых потоках, используя AsyncTask, HandlerThread, или другие механизмы многопоточности."
            ]
          },
          {
            "questionText": "Що таке DataBinding?",
            "answerItems": [
              "DataBinding - это библиотека Android, позволяющая привязывать UI компоненты в layouts напрямую к источникам данных в приложении.",
              "Это уменьшает код для обновления UI и предотвращает ошибки, так как данные автоматически обновляются при изменении."
            ]
          },
          {
            "questionText": "Що таке LiveData? Які види знаєте?",
            "answerItems": [
              "LiveData - это observable data holder class, который используется в сочетании с архитектурными компонентами, такими как ViewModel.",
              "Он автоматически обновляет данные в UI, учитывая жизненный цикл компонентов. Виды: MutableLiveData, MediatorLiveData."
            ]
          },
          {
            "questionText": "Як створити ViewModel? Чому створювати ViewModel потрібно саме так?",
            "answerItems": [
              "ViewModel создается через ViewModelProvider. Это обеспечивает сохранение данных ViewModel при изменении конфигурации, например при повороте экрана.",
              "ViewModel помогает управлять данными UI и разделять логику приложения от интерфейса, что повышает читаемость и упрощает тестирование."
            ]
          },
          {
            "questionText": "Що таке Context і навіщо він?",
            "answerItems": [
              "Context в Android - это интерфейс, который предоставляет доступ к ресурсам приложения, базе данных, настройкам и другим функциям.",
              "Он используется для получения доступа к сервисам Android (например, LayoutInflater), старту активностей и доступа к системным ресурсам."
            ]
          },
          {
            "questionText": "Що таке AndroidManifest.xml? Для чого його використовують? Що ми можемо там декларувати?",
            "answerItems": [
              "AndroidManifest.xml - это файл в Android приложении, который содержит информацию о приложении для Android системы.",
              "В нем декларируются компоненты приложения (активности, сервисы, broadcast receivers, content providers), разрешения, поддерживаемые устройствами характеристики.",
              "Также он используется для определения уровня API, версии приложения и других метаданных."
            ]
          },
          {
            "questionText": "Перерахуйте layout, з якими працювали? Коли і який потрібно використовувати?",
            "answerItems": [
              "LinearLayout: Используется для размещения элементов в одном направлении (вертикально или горизонтально). Идеально подходит для простых layouts.",
              "RelativeLayout: Позволяет расположить дочерние элементы относительно друг друга или родителя. Хорошо подходит для сложных layouts.",
              "FrameLayout: Используется для размещения одного элемента поверх другого. Подходит для простых сценариев, где необходимо разместить один элемент над другим.",
              "ConstraintLayout: Мощный и гибкий layout, который позволяет создавать сложные интерфейсы с минимальной вложенностью и лучшей производительностью.",
              "GridLayout: Используется для размещения элементов в сетке. Подходит для создания таблиц или сеточных интерфейсов."
            ]
          },
          {
            "questionText": "Розкажіть, що треба реалізувати, щоб відобразити список рядків у RecyclerView.",
            "answerItems": [
              "Создать layout для отдельного элемента списка.",
              "Определить класс ViewHolder, который предоставляет ссылку на все представления в элементе списка.",
              "Создать адаптер RecyclerView.Adapter, который связывает данные со списком и управляет ViewHolder'ами.",
              "Инициализировать RecyclerView в активности или фрагменте и установить ему адаптер."
            ]
          },
          {
            "questionText": "Поясніть патерн ViewHolder. Для чого він застосовується?",
            "answerItems": [
              "ViewHolder в Android используется для оптимизации производительности RecyclerView, уменьшая количество вызовов findViewById.",
              "Он хранит ссылки на представления, которые уже были загружены, тем самым ускоряя процесс прокрутки и повторного использования элементов списка."
            ]
          },
          {
            "questionText": "Що таке DiffUtil?",
            "answerItems": [
              "DiffUtil - это утилита в Android, предназначенная для вычисления различий между двумя списками и выдачи обновлений элементов в RecyclerView.",
              "Она помогает оптимизировать отображение данных в RecyclerView, обновляя только те элементы, которые изменились."
            ]
          },
          {
            "questionText": "Розкажіть про ConstraintLayout.",
            "answerItems": [
              "ConstraintLayout - это гибкий и мощный layout менеджер, который позволяет создавать сложные и адаптивные UI без необходимости вложенных представлений.",
              "Он поддерживает различные типы ограничений для позиционирования и размера виджетов, такие как привязки к другим виджетам, выравнивание, размеры и отступы."
            ]
          },
          {
            "questionText": "Для чого використовують Group, Guideline, Barriers, Chains у ConstraintLayout?",
            "answerItems": [
              "Group: Используется для группировки нескольких элементов интерфейса, что позволяет одновременно изменять их видимость или другие атрибуты.",
              "Guideline: Невидимый элемент, который помогает в выравнивании других элементов. Может быть ориентирован горизонтально или вертикально.",
              "Barriers: Предоставляют способ создания барьера, который ограничивает группу элементов с одной стороны, упрощая компоновку сложных макетов.",
              "Chains: Позволяют создавать горизонтальные или вертикальные цепочки элементов, которые распределяются или выравниваются определенным образом в рамках макета."
            ]
          },
          {
            "questionText": "У вас є Activity з двома Fragment’ами, в одного є кнопка, в іншого — TextView. Якщо натискаєте кнопку, змінюється TextView. Як ви реалізуєте це?",
            "answerItems": [
              "Для связи между фрагментами используйте callback-интерфейс в Activity. Когда пользователь нажимает кнопку в одном фрагменте, фрагмент вызывает метод интерфейса в Activity.",
              "Activity, в свою очередь, обращается к другому фрагменту и вызывает метод для обновления TextView.",
              "Такой подход обеспечивает разделение ответственности между фрагментами и Activity, улучшая модульность и управляемость кода."
            ]
          },
          {
            "questionText": "Що таке WorkManager? Коли використовуємо?",
            "answerItems": [
              "WorkManager - это часть Android Jetpack, предназначенная для управления фоновыми задачами, которые должны выполняться в определенных условиях и могут быть отложенными.",
              "Используется для задач, требующих надежного выполнения, например, для синхронизации данных, обработки данных в фоне, выполнения задач в определенное время или при наличии сетевого соединения.",
              "Особенно полезен в случаях, когда задачи должны быть выполнены даже после закрытия приложения или перезагрузки устройства."
            ]
          }
        ]
      },
      {
        "topic": "Kotlin",
        "questions": [
          {
            "questionText": "Як ви розумієте термін Null safety?",
            "answerItems": [
              "Это механизм, предотвращающий NullPointerException (когда программа пытается использовать (поле или метод) объект с ссылкой null).",
              "В Kotlin, переменные не могут принимать значение null по умолчанию. Чтобы переменная могла быть null, она должна быть явно объявлена с использованием знака вопроса (напр.: 'val tmp : String? = null')."
            ]
          },
          {
            "questionText": "Що таке nullable та non-nullable типи? Яка різниця між val та var?",
            "answerItems": [
              "Nullable типы - могут принимать значение null.",
              "Non-nullable - НЕ могут принимать значение null.",
              "'val' - это immutable (значение нельзя изменить после инициализации) переменная (похожа на final в Java). ",
              "'var' - это mutable переменная, значение которой можно изменить."
            ]
          },
          {
            "questionText": "Як задекларувати getter/setter для property?",
            "answerItems": [
              "Kotlin автоматически предоставляет эти методы, но их можно переопределить.",
              "Для переопределения getter и setter, используйте 'get()' и 'set(value)' после объявления свойства:",
              "class Rectangle(val width: Int, val height: Int) {\n    val area: Int\n        get() = this.width * this.height\n}",
              "val area get() = this.width * this.height",
              "при необходимости дефолтный сеттер можно сделать приватным:",
              "class Tmp(){\n    val name : String\n    \tget() = \"HI\"\n    \n    var area = 3\n    \tget() = 2 * 5\n    \tprivate set\n    \n    var age : Int = 0\n    \tget() = field\n    \tset(value) { field = value }\n}"
            ]
          },
          {
            "questionText": "Чому класи Kotlin за замовчуванням final?",
            "answerItems": [
              "Такой подход способствует безопасности и предотвращает непреднамеренное наследование.",
              "Поддерживает концепцию 'проектирования для наследования' (класс разрешено наследовать только если он явно объявлен как 'open' или 'abstract')."
            ]
          },
          {
            "questionText": "Що таке data classes?",
            "answerItems": [
              "Data class предназначен для хранения данных. \n- Kotlin автоматически генерирует методы 'equals()', 'hashCode()', 'toString()' и 'copy()'.",
              "- Идеально подходит для создания моделей данных, содержащих только данные (поля)."
            ]
          },
          {
            "questionText": "Що таке sealed class?",
            "answerItems": [
              "Sealed class нужен для создания иерархии классов с ограниченным набором ПОДклассов, каждый из которых может иметь свое уникальное состояние и методы.",
              "Все подклассы sealed класса должны быть объявлены в том же файле, что и sealed класс.",
              "Позволяет использовать 'when' без блока 'else', так как все возможные варианты известны заранее."
            ]
          },
          {
            "questionText": "Яка різниця між sealed class та enum?",
            "answerItems": [
              "Sealed class нужен для создания иерархии классов с ограниченным набором ПОДклассов, каждый из которых может иметь свое уникальное состояние и методы.",
              "Enum - это ограниченный набор констант (например, дни недели),\n      - все экземпляры enum типа являются static & immutable."
            ]
          },
          {
            "questionText": "Чому в Kotlin немає checked exceptions?",
            "answerItems": [
              "Відповідь потребує допрацювання!!!",
              "В Kotlin не используются checked exceptions, так как они могут приводить к чрезмерному 'обертыванию' кода исключениями (exception boilerplate), что затрудняет чтение и поддержку кода.",
              "Вместо этого Kotlin предоставляет более гибкий подход к обработке ошибок, позволяя разработчикам самостоятельно решать, как обрабатывать исключения."
            ]
          },
          {
            "questionText": "Що таке Extensions? Чи використовували їх на практиці?",
            "answerItems": [
              "Extensions (расширения) позволяют добавлять новые функции к существующим классам без их модификации.",
              "Эти функции, как правило, используются для добавления вспомогательных методов к классам, для которых исходный код недоступен, например, к классам стандартной библиотеки."
            ]
          },
          {
            "questionText": "Як працюють примітиви в Kotlin?",
            "answerItems": [
              "В Kotlin примитивные типы, такие как Int, Double, Float и другие, представлены как объекты для обеспечения единообразия языка.",
              "Однако при компиляции Kotlin эффективно использует соответствующие примитивные типы Java для оптимизации производительности и уменьшения потребления памяти."
            ]
          },
          {
            "questionText": "Розкажіть про об’єкт Unit у Kotlin.",
            "answerItems": [
              "'Unit' в Kotlin аналогичен 'void' в Java. Он используется для обозначения функций, которые не возвращают значимый результат.",
              "В отличие от Java, 'Unit' является полноценным объектом, что позволяет его использовать как тип в обобщениях и переменных."
            ]
          },
          {
            "questionText": "Розкажіть про об’єкт Any в Kotlin.",
            "answerItems": [
              "'Any' - это корневой тип для всех непримитивных типов в Kotlin. Он аналогичен 'Object' в Java.",
              "Любой пользовательский или встроенный класс в Kotlin наследуется от 'Any', который содержит базовые методы, такие как 'equals()', 'hashCode()' и 'toString()'."
            ]
          },
          {
            "questionText": "Як створити Singleton об’єкт в Kotlin?",
            "answerItems": [
              "C помощью ключевого слова 'object'.",
              "Объявление 'object' обеспечивает глобальный единственный экземпляр класса."
            ]
          },
          {
            "questionText": "Що таке companion object?",
            "answerItems": [
              "Это объект который существует в единственном экземпляре для данного класса.",
              "Используется для объявления статических членов класса (хотя статикой НЕ является)",
              "Это позволяет обращаться к \"статическим\" членам (методам или свойствам) без создания экземпляра класса."
            ]
          },
          {
            "questionText": "Чим відрізняється const val від val?",
            "answerItems": [
              "'const val' используется для объявления immutable констант на уровне класса или объекта.",
              "- Во время компиляции обязанны быть известны.",
              "'val' используется для объявления immutable переменных",
              "- Во время компиляции могут быть НЕ известны и определяться в runtime."
            ]
          },
          {
            "questionText": "Які знаєте модифікатори доступу?",
            "answerItems": [
              "В Kotlin существуют следующие модификаторы доступа: 'public', 'private', 'protected' и 'internal'.",
              "'public' (по-умолчанию): видимость на уровне всего проекта. (В Java нужно явно указывать)",
              "'private': видимость ограничена контекстом объявления: классом, файлом. (В Java ограниченя классом). Можно сделать приватный конструктор для синглтона.",
              "'protected': как 'private', но видимый в подклассах. (В Java видимый в подклассах & в package - папка, в которой лежит клас)",
              "'internal': видимость ограничена одним Gradle-модулем. (В Java такого нет. Есть default - видимый в package. Устанавливается по-умолчанию, если не указать другого)"
            ]
          },
          {
            "questionText": "Що означає модифікатор lateinit?",
            "answerItems": [
              "Модификатор 'lateinit' в Kotlin используется для объявления свойств, которые будут инициализированы позже, после создания объекта.",
              "Он полезен в случаях, когда инициализация не может быть выполнена в конструкторе, например, из-за зависимости от DI фреймворка или системных вызовов Android."
            ]
          },
          {
            "questionText": "Coroutines — що це за механізм? Чи використовували його на практиці?",
            "answerItems": [
              "Coroutines в Kotlin - это 'сопрограммы', легковесные потоки, предназначенные для асинхронного выполнения задач с минимальными затратами на ресурсы.",
              "Они позволяют писать асинхронный код последовательно, упрощая управление асинхронными операциями, такими как сетевые запросы, доступ к базе данных и т. д."
            ]
          },
          {
            "questionText": "Що таке suspend-функція?",
            "answerItems": [
              "'suspend' в Kotlin - это специальный тип функции, который может быть приостановлен без блокировки потока и возобновлен позже.",
              "Они являются ключевой частью работы с Kotlin Coroutines и позволяют выполнять асинхронные операции, такие как сетевые запросы, работу с БД или чтение файлов, более эффективно.",
              "'suspend' можно вызвать только из других suspend функций или из корутин (suspend блоков)",
              ".launch{} или .async{}  -  лямбды помеченные ключевым словом suspend."
            ]
          },
          {
            "questionText": "Що таке Job?",
            "answerItems": [
              "'Job' в Kotlin Coroutines",
              "- це object, що реалізує abstract class AbstractCoroutineContextElement : CoroutinContext.Element",
              "- это обработчик, который представляет собой выполнение одной корутины.",
              "- позволяет управлять жизненным циклом корутины, отменять ее, может использоваться для контроля группы корутин, создавая иерархию.",
              "Использование:",
              "val job = CoroutineScope(Dispatchers.IO).launch{ ... }\n... job.cancel()",
              "val job = flowOf(1,2,3).launchIn(scope) - джоба завершится автоматически после ємита последнего значения"
            ]
          },
          {
            "questionText": "Що таке Dispatcher? Які є види?",
            "answerItems": [
              "'Dispatcher' в Kotlin Coroutines:",
              "- це object, що реалізує abstract class AbstractCoroutineContextElement : CoroutinContext.Element",
              "- він задає контекст в якому буде виконуватись корутина (у тому числі в якому потоці або групі потоків).",
              "Основные типы:\n- 'Dispatchers.Main' (главный поток в Android),\n- 'Dispatchers.Main.immediate' (если нужно гарантировать мгновенное отображение на UI),\n- 'Dispatchers.IO' (для операций ввода-вывода, походов в сеть или БД),\n- 'Dispatchers.Default' (оптемизирован для CPU-интенсивных задач: напр. сложных мат. вычислений),\n- 'Dispatchers.Unconfined' (выполняется в текущем потоке, но не ограничен им).",
              "Использование: CoroutineScope(Dispatchers.IO).launch{ ... }"
            ]
          },
          {
            "questionText": "Як писати Java-compatible (Java-сумісний) API на Kotlin?",
            "answerItems": [
              "Відповідь потребує допрацювання!!!",
              "Для создания Java-совместимого API в Kotlin стоит учитывать нюансы взаимодействия между Kotlin и Java. Напр.: обработка null-значений, типы коллекций и примитивы.",
              "Используйте '@JvmStatic', '@JvmOverloads' и '@JvmField' аннотации для управления генерацией Java-кода из Kotlin-кода, чтобы сделать его более доступным и понятным для Java-разработчиков."
            ]
          }
        ]
      },
      {
        "topic": "Інше",
        "questions": [
          {
            "questionText": "Розкажіть, що таке memory leak. Як уникати?",
            "answerItems": [
              "Memory leak (утечка памяти) происходит, когда приложение занимает память и не освобождает её, что может привести к исчерпанию доступной памяти (OutOfMemoryError) и остановке приложения.",
              "Для избежания утечек памяти следует тщательно управлять ресурсами, освобождая их после использования, избегать удержания ненужных ссылок и использовать инструменты профилирования памяти для выявления потенциальных утечек."
            ]
          },
          {
            "questionText": "Як би ви шукали memory leak?",
            "answerItems": [
              "Для поиска утечек памяти используются инструменты профилирования, такие как Android Studio Profiler, LeakCanary в Android, инструменты разработчика в браузерах для веб-приложений.",
              "Эти инструменты позволяют отслеживать использование памяти и выявлять объекты, которые не освобождаются, указывая на потенциальные утечки."
            ]
          },
          {
            "questionText": "Розкажіть про Dependency injection? Які варіанти реалізації в Android?",
            "answerItems": [
              "Dependency Injection (внедрение зависимостей) - это техника, при которой один объект предоставляет зависимости другому объекту. Это улучшает тестируемость и модульность кода.",
              "В Android часто используются такие библиотеки, как Dagger, Hilt или Koin"
            ]
          },
          {
            "questionText": "Для чого потрібна система контролю версій?",
            "answerItems": [
              "Система контроля версий, такая как Git, позволяет отслеживать изменения в коде, возвращаться к предыдущим версиям, сотрудничать с другими разработчиками, управлять параллельной разработкой и устранять конфликты."
            ]
          },
          {
            "questionText": "Що таке Git?",
            "answerItems": [
              "Git - это распределенная система контроля версий (созданная Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005) которая позволяет отслеживать и управлять изменениями в коде, облегчает сотрудничество между разработчиками и поддерживает несколько рабочих потоков разработки.",
              "GitHub - это хост (удаленный сервер), на котором хранятся история созданная Git"
            ]
          },
          {
            "questionText": "Для чого використовуємо .gitignore-файл?",
            "answerItems": [
              "Файл .gitignore используется для указания Git, какие файлы или папки следует игнорировать (не реагировать на изменения и не хранить в репозитории), напр: временные файлы, личные настройки IDE (/.idea или local.properties или .obsidian/workspace.json)."
            ]
          },
          {
            "questionText": "Розкажіть про команди push, pull, fetch у Git?",
            "answerItems": [
              "'git push' используется для отправки локальных изменений в удаленный репозиторий.",
              "'git pull' забирает изменения с удаленного репозитория и сливает их с локальной веткой.",
              "'git fetch' загружает изменения с удаленного репозитория, но не сливает их с локальной веткой."
            ]
          },
          {
            "questionText": "Що таке merge і rebase? Яка різниця?",
            "answerItems": [
              "'merge' объединяет изменения из другой ветки в текущую: \n-> сохраняет коммиты в текущей ветке (cmt1, cmt2) \n-> добавляет коммит из другой ветки (cmt3) \n+ создает новый коммит слияния (Merge branch \"Имя другой ветки\" into \"Имя текущей ветки\"). \nПлюсы: \n- все конфликты решаются за один подход, \n- Пуш на origin выполнится всегда, даже если там появился новый коммит от коллеги.\nМинусы: \n- Бывает сложно понять историю изменений",
              "'rebase' переносит изменения из другой ветки и ставит коммиты текущей ветки на вершину, создавая линейную историю. \nПлюсы: \n - Легко понять историю изменений.\nМинусы: \n- Змінює сигнатури коммітів нагальної гілки - що унеможливлює простий пуш на origin. Вихід - только удалять оригинал текущей ветки с origin и тогда можно запушить текущую.\n- Конфликты решаются для каждого переносимого коммита отдельно. Бывает, что одни и те же конфликты приходится решать много раз, причем каждый раз по разному."
            ]
          },
          {
            "questionText": "Що таке CI? Для чого використовуємо?",
            "answerItems": [
              "CI (Continuous Integration) - это практика автоматического тестирования и слияния изменений кода в общий репозиторий. \n- Уменьшает риски конфликтов, \n- Улучшает качество кода, \n- ускоряет процесс разработки.",
              "Plan > Code > Build > Test",
              "CD (Continuous Delivery) - автоматизация доставки продукта пользователю",
              "Release > Deploy > Operate > Monitor"
            ]
          }
        ]
      },
      {
        "topic": "Практичні завдання",
        "questions": [
          {
            "questionText": "Розгорніть LinkedList. Відпишіть про зацикленість у LinkedList або її відсутність.",
            "answerItems": [
              "- У Java є LinkedList, LinkedHashMap, LinkedHashSet",
              "- У Kotlin є лише LinkedHashMap, LinkedHashSet",
              "Однозв'язний список - перший елемент (голова) має посилання на наступний елемент",
              "Двозв'язний список - перший елемент (голова) має посилання на другий елемент, а середні елементи - знають про сусідів (наступний та попередній)",
              "Розворот - це заміна посилань, щоб \"голова\" стала \"хвостом\" (останнім елементом), другий елемент став передостаннім і т.д.",
              "// Функция для проверки наличия цикла в LinkedList по алгоритму \"замедленной зайки\" O(n)\n    public static boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head.next;\n\n        while (fast != null && fast.next != null) {\n            if (slow == fast) {\n                return true; // Найден цикл\n            }\n            slow = slow.next;         // Перемещаем медленный указатель на один шаг\n            fast = fast.next.next;    // Перемещаем быстрый указатель на два шага\n        }\n\n        return false; // Цикл не найден\n    }\n"
            ]
          },
          {
            "questionText": "Напишіть функцію, яка поверне n перших невід’ємних чисел:\nНапр.: nMin(listOf(\"1\",\"-11\",\"-12\",\"22\",\"100\",\"-30\",\"2\",\"5\"), 3)  поверне: [1, 22, 100]",
            "answerItems": [
              "fun nMin(items: List<String>, n: Int): List<Int> { \n\treturn items.map{it.toInt()}.filter{it >= 0}.take(n)\n} \n.take(n) or .slice(0..n-1) \n також корисна функція: val indexes = arrayOf(2, 4, 6)\nallColours.filterIndexed { index, s -> indexes.contains(index) }"
            ]
          },
          {
            "questionText": "Що буде виведено в консоль? Поясніть результат.",
            "answerItems": [
              "var globalId = 0 \ndata class User(val name: String) { \nval id = globalId++ \n} \nfun main(args: Array<String>) { \nval user1 = User(\"User\") \nval user2 = User(\"User\") \nprintln(user1) \nprintln(user2) \nprintln(user1 == user2) \n} ",
              "Буде виведено \nUser(name=User)\nUser(name=User)\ntrue\n Тому, що компілятор для перевизначення функції .equals() використовує поля класу вказані у головному конструкторі та ігнорух поля классу вказані у тілі класу."
            ]
          },
          {
            "questionText": "Виправте всі помилки в коді:",
            "answerItems": [
              "class Animal \nclass Dog : Animal {}",
              "Без ключового слова \"open\" клас Animal не можна унаслідувати. Вірно: \"open class Animal\"",
              "Підчас унаслідування необхідно вказувати конструктор для батьківськаого класу. \"Вірно: class Dog: Animal()\""
            ]
          },
          {
            "questionText": "Для колекції items: \n\"val items = listOf(1, -2 ,-3 , 4, 5, 0, 2, -2)\"",
            "answerItems": [
              "Порахуйте кількість негативних елементів. \nВірно: \"val amount = items.count{it < 0}\"",
              "Розрахуйте середнє арифметичне значення від’ємних і невід’ємних чисел. \nВірно: \"val avrgPositive = items.filter{it >= 0}.average()\""
            ]
          }
        ]
      }
    ]
  },
  {
    "levelTitle": "Middle",
    "questions": [
      {
        "topic": "Базові питання",
        "questions": [
          {
            "questionText": "Чи потрібно дотримуватися SOLID-принципів? Чому так/ні?",
            "answerItems": [
              "Дотримання SOLID-принципів сприяє створенню більш читабельного, гнучкого та підтримуваного коду, а також полегшує тестування та внесення змін у програмне забезпечення.",
              "Хоча в деяких випадках строге дотримання SOLID може здатися надмірним, особливо у малих або простих проектах, загалом ці принципи допомагають уникнути часто зустрічаних проблем у розробці ПЗ."
            ]
          },
          {
            "questionText": "Які патерни використовували на практиці? Наведіть приклади.",
            "answerItems": [
              "Singleton: Для створення єдиного екземпляра класу, що використовується у всьому додатку (наприклад, менеджер конфігурації).",
              "Observer: Для реалізації підписки на події чи зміни у даних (наприклад, оновлення UI при зміні стану моделі).",
              "Factory Method: Для створення об'єктів без вказівки конкретних класів об'єктів (наприклад, створення різних типів документів у текстовому редакторі)."
            ]
          },
          {
            "questionText": "Опишіть патерни MVP та MVVM. Які з них використовували? Якому віддаєте перевагу? Чи знаєте/використовували інші патерни?",
            "answerItems": [
              "MVP (Model-View-Presenter): Розділяє представлення (View), логіку представлення (Presenter) та бізнес-логіку (Model). Presenter взаємодіє між View та Model, відокремлюючи логіку від UI.",
              "MVVM (Model-View-ViewModel): View зв'язується з ViewModel, яка представляє стан та логіку представлення, тоді як Model забезпечує бізнес-логіку та дані. ViewModel спрощує тестування та відокремлення логіки від UI.",
              "Перевага часто віддається MVVM через кращу підтримку реактивного програмування та зручність використання у зв'язці з такими фреймворками, як Android Data Binding."
            ]
          },
          {
            "questionText": "Чому шар Model має бути відокремленим від View чи Presenter?",
            "answerItems": [
              "Відокремлення Model від View та Presenter сприяє розподілу відповідальності, полегшує тестування та підтримку коду, а також забезпечує гнучкість для змін інтерфейсу користувача без впливу на бізнес-логіку."
            ]
          },
          {
            "questionText": "Що таке інверсія залежності (dependency inversion)?",
            "answerItems": [
              "Інверсія залежності - це принцип, згідно з яким модулі вищого рівня не повинні залежати від модулів нижчого рівня, а обидва типи модулів повинні залежати від абстракцій. Це сприяє зниженню залежності між різними частинами коду."
            ]
          },
          {
            "questionText": "Поясніть приклад патерну Singleton. Де його використовувати в Android?",
            "answerItems": [
              "Патерн Singleton у Android можна використовувати для створення класів, які повинні мати лише один екземпляр у всьому додатку, наприклад, менеджер налаштувань або бази даних."
            ]
          },
          {
            "questionText": "Поясніть приклад патерну Observer. Де його використовувати в Android?",
            "answerItems": [
              "Патерн Observer у Android можна використовувати для реалізації спостереження за змінами даних чи стану, наприклад, при оновленні UI відповідно до змін у моделі даних через LiveData або RxJava."
            ]
          },
          {
            "questionText": "Поясніть приклад патерну Builder. Де його використовувати в Android?",
            "answerItems": [
              "Патерн Builder можна застосовувати в Android для створення складних об'єктів, наприклад, побудова діалогових вікон або складних запитів до бази даних."
            ]
          },
          {
            "questionText": "Як ви розумієте термін «архітектура застосунку»? Навіщо це взагалі потрібно?",
            "answerItems": [
              "Архітектура застосунку - це спосіб організації програмного коду, який визначає структуру додатку, включаючи розподіл відповідальності, взаємодію між компонентами та управління залежностями.",
              "Добре продумана архітектура важлива для створення масштабованого, підтримуваного та тестируємого додатку. Вона допомагає уникнути 'спагеті-коду', спрощує розуміння та розширення додатку."
            ]
          },
          {
            "questionText": "Що таке імутабельний об’єкт? Навіщо його застосовують? Як зробити імутабельний об’єкт у Java?",
            "answerItems": [
              "Імутабельний об'єкт - це об'єкт, стан якого не може бути змінений після його створення.",
              "Використання імутабельних об'єктів сприяє безпеці програми, ускладнює виникнення помилок, пов'язаних зі зміною даних, і полегшує роботу в многопоточному середовищі.",
              "У Java імутабельний об'єкт можна створити, оголосивши всі його поля як 'final' і не надаючи методів, які б могли змінити ці поля."
            ]
          },
          {
            "questionText": "MVP vs MVVM — в чому основна відмінність?",
            "answerItems": [
              "MVP (Model-View-Presenter) та MVVM (Model-View-ViewModel) - це архітектурні патерни для організації коду в застосунках.",
              "У MVP Presenter відповідає за логіку представлення, обробляє всю взаємодію з користувачем, зв'язуючись з View і Model. View у MVP зазвичай пасивна і просто відображає те, що подає Presenter.",
              "У MVVM ViewModel виконує роль посередника між View і Model, забезпечуючи потрібні дані для View. Важливою особливістю MVVM є наявність механізму прив'язки даних (Data Binding), який дозволяє створювати більш декларативні інтерфейси."
            ]
          }
        ]
      },
      {
        "topic": "Алгоритми",
        "questions": [
          {
            "questionText": "Є багато алгоритмів сортування. Чи можливо обрати один найшвидший та використовувати його всюди? Чому так/ні?",
            "answerItems": [
              "Немає універсального 'найшвидшого' алгоритму сортування, оскільки вибір оптимального алгоритму залежить від багатьох факторів, таких як розмір даних, ступінь їх впорядкованості та доступні ресурси.",
              "Деякі алгоритми, як QuickSort, ефективні в більшості сценаріїв, але можуть бути неефективними у певних умовах, наприклад, при великій кількості повторюваних елементів.",
              "Інші алгоритми, як MergeSort, гарантують стабільне сортування з відносно передбачуваною швидкістю, але вимагають додаткового простору пам'яті."
            ]
          },
          {
            "questionText": "У чому складність пошуку довільного елемента в ArrayList? У LinkedList?",
            "answerItems": [
              "У ArrayList пошук довільного елемента є ефективним (O(1)), оскільки дані зберігаються у неперервному блоку пам'яті, і доступ до будь-якого елемента можливий безпосередньо.",
              "У LinkedList пошук довільного елемента вимагає перебору елементів з початку або кінця списку, що в середньому вимагає перегляду половини елементів (O(n))."
            ]
          },
          {
            "questionText": "Які алгоритми використовують в Android/Java колекціях під капотом?",
            "answerItems": [
              "Java колекції, такі як ArrayList і HashMap, використовують різноманітні алгоритми. Наприклад, HashMap використовує хеш-таблиці для швидкого доступу до елементів.",
              "Для сортування Java використовує TimSort, модифіковану версію MergeSort, яка ефективно працює з частково впорядкованими даними.",
              "В колекціях, як LinkedList, використовуються базові алгоритми для структур даних з подвійним зв'язком."
            ]
          }
        ]
      },
      {
        "topic": "Структури даних",
        "questions": [
          {
            "questionText": "HashMap. Чи використовуєте на практиці? Якщо так, то для чого? Як вона працює зсередини?",
            "answerItems": [
              "HashMap часто використовується на практиці для зберігання і швидкого доступу до даних за ключем. Вона ефективна для реалізації асоціативних масивів, кешування, відстеження унікальних елементів.",
              "HashMap працює на основі хеш-таблиці. Ключі в HashMap хешуються, а хеш-функція визначає індекс в масиві для зберігання пар ключ-значення.",
              "У разі колізій, коли різні ключі мають однаковий хеш, HashMap використовує структуру даних, таку як зв'язний список або червоно-чорне дерево, для зберігання об'єктів."
            ]
          },
          {
            "questionText": "Яка різниця між HashMap та LinkedHashMap?",
            "answerItems": [
              "Основна відмінність між HashMap і LinkedHashMap полягає в порядку ітерації. LinkedHashMap зберігає порядок додавання елементів, тоді як HashMap не гарантує жодного порядку.",
              "LinkedHashMap використовує додаткову структуру даних (двонаправлені вказівники) для зберігання порядку елементів, що трохи збільшує споживання пам'яті порівняно з HashMap."
            ]
          },
          {
            "questionText": "Що таке бінарне дерево?",
            "answerItems": [
              "Бінарне дерево - це структура даних, в якій кожен вузол має не більше двох дочірніх елементів, зазвичай відомих як 'лівий' і 'правий' дочірні вузли.",
              "Бінарні дерева часто використовуються для реалізації бінарних дерев пошуку, де лівий дочірній вузол має значення менше, ніж батьківський вузол, а правий - більше.",
              "Ця структура дозволяє ефективно виконувати пошук, вставку та видалення елементів."
            ]
          }
        ]
      },
      {
        "topic": "Збереження даних",
        "questions": [
          {
            "questionText": "Як би ви реалізували збереження зашифрованих даних у SharedPreferences? Базу даних?",
            "answerItems": [
              "Для збереження зашифрованих даних у SharedPreferences можна використовувати бібліотеки шифрування, такі як AES, і зберігати шифрований текст замість відкритого тексту.",
              "Для баз даних використовуються механізми шифрування на рівні бази даних, наприклад, SQLCipher, який дозволяє шифрувати цілі бази даних.",
              "Також можна шифрувати окремі поля перед збереженням у базі даних за допомогою шифрувальних алгоритмів."
            ]
          },
          {
            "questionText": "Як реалізувати міграцію таблиці, де потрібно з non-nullable поля зробити nullable поле?",
            "answerItems": [
              "Для реалізації міграції таблиці в базі даних, де non-nullable поле потрібно зробити nullable, спершу треба оновити схему бази даних.",
              "Це може включати в себе зміну визначення стовпця в схемі бази даних, щоб дозволити null значення.",
              "Потім потрібно написати скрипт міграції, який буде застосовуватися при оновленні бази даних, змінюючи структуру існуючих таблиць відповідно до нової схеми."
            ]
          }
        ]
      },
      {
        "topic": "Робота з мережею",
        "questions": [
          {
            "questionText": "Розкажіть, які методи можемо застосувати в REST API? Для чого який потрібен?",
            "answerItems": [
              "GET: Використовується для запиту даних з сервера. Найчастіше використовується для отримання інформації.",
              "POST: Використовується для створення нових записів. Дані, що відправляються, зазвичай не відображаються в URL.",
              "PUT: Використовується для оновлення існуючих записів на сервері.",
              "DELETE: Використовується для видалення записів.",
              "PATCH: Схожий на PUT, але використовується для оновлення частини даних запису."
            ]
          },
          {
            "questionText": "Що можна використовувати, крім REST API, для роботи із сервером?",
            "answerItems": [
              "GraphQL: Язык запитів, який дозволяє клієнтам точно вказувати, які дані їм потрібні.",
              "WebSocket: Протокол, що дозволяє двостороннє з'єднання між клієнтом і сервером для реалізації реального часу.",
              "SOAP: Протокол для обміну структурованими повідомленнями; використовує XML для кодування повідомлень."
            ]
          }
        ]
      },
      {
        "topic": "Багатопотоковість",
        "questions": [
          {
            "questionText": "Що таке Thread Pool? Які його особливості?",
            "answerItems": [
              "Thread Pool - це група заздалегідь створених потоків, які можна використовувати для виконання багатьох коротких завдань.",
              "Основні особливості включають зменшення витрат на створення і знищення потоків, управління кількістю потоків, що працюють одночасно, і підвищення продуктивності застосунків, що часто використовують многопоточність."
            ]
          },
          {
            "questionText": "Що таке Executor/ExecutorService? Яке завдання виконують і як використовувати?",
            "answerItems": [
              "Executor і ExecutorService в Java - це інтерфейси, які надають засоби для управління потоками і асинхронного виконання завдань.",
              "Вони дозволяють легко управляти Thread Pools, виконувати завдання асинхронно, а також контролювати прогрес і результат виконання завдань."
            ]
          },
          {
            "questionText": "Які є види Executor?",
            "answerItems": [
              "FixedThreadPool: Пул потоків з фіксованою кількістю потоків.",
              "CachedThreadPool: Пул потоків, який створює нові потоки, коли це потрібно, і використовує раніше створені, коли вони доступні.",
              "ScheduledThreadPool: Пул потоків для виконання завдань з затримкою або періодично.",
              "SingleThreadExecutor: Пул потоків, який використовує один потік для виконання завдань."
            ]
          },
          {
            "questionText": "Яка різниця між методами start() і run() в класі Thread?",
            "answerItems": [
              "Метод 'start()' створює новий потік і викликає метод 'run()' в цьому новому потоці, дозволяючи асинхронне виконання завдань.",
              "Метод 'run()' виконує завдання в поточному потоці, тому його прямий виклик не створює новий потік і виконується синхронно."
            ]
          },
          {
            "questionText": "На що вказує ключове слово synchronized? Яка його основна функція?",
            "answerItems": [
              "Ключове слово 'synchronized' вказує на те, що метод або блок коду може бути виконаний одночасно тільки одним потоком.",
              "Основна функція - забезпечити взаємовиключення, що допомагає уникнути проблем з одночасним доступом до спільних ресурсів і 'ефекту перегонів'."
            ]
          },
          {
            "questionText": "Модифікатор volatile. Чи доводилося використовувати? Навіщо потрібен?",
            "answerItems": [
              "Модифікатор 'volatile' використовується для змінних, які можуть бути змінені різними потоками. Він гарантує, що змінна буде завжди читатися з головної пам'яті, а не з кешу потока.",
              "Це важливо для забезпечення відповідності даних між потоками, оскільки без 'volatile' потоки можуть не бачити останніх змін у змінних, зроблених іншими потоками."
            ]
          },
          {
            "questionText": "Чи знаєте про таке поняття, як «ефект перегонів» (race condition)? Як цьому запобігти? Які є механізми в Java для запобігання цьому?",
            "answerItems": [
              "«Ефект перегонів» (race condition) відбувається, коли кілька потоків одночасно змагаються за доступ до спільного ресурсу, що може призвести до непередбачуваної поведінки програми.",
              "Для запобігання можна використовувати синхронізацію за допомогою 'synchronized', блокування за допомогою класів з пакету java.util.concurrent, наприклад, ReentrantLock, а також атомарні класи, як AtomicInteger."
            ]
          },
          {
            "questionText": "Що таке атомарна операція?",
            "answerItems": [
              "Атомарна операція - це операція, яка виконується цілком без можливості переривання іншими потоками, що гарантує її виконання як єдиного цілого.",
              "У Java, атомарні операції часто виконуються з використанням атомарних класів з пакету java.util.concurrent.atomic, які забезпечують безпечний доступ до змінних в многопоточному середовищі."
            ]
          },
          {
            "questionText": "Як зупинити потік у Java? Чи можна продовжити виконання потоку після його зупинки?",
            "answerItems": [
              "У Java припинення потоку може бути виконано за допомогою установки прапорця, який перевіряється всередині циклу потоку. Метод 'Thread.stop()' застарілий та небезпечний.",
              "Продовжити виконання потоку після його зупинки не можна; для повторного виконання завдань потрібно створити новий потік."
            ]
          },
          {
            "questionText": "Чи знаєте про потокобезпечні колекції у Java/Android? Чи доводилося їх використовувати?",
            "answerItems": [
              "Потокобезпечні колекції, такі як ConcurrentHashMap, CopyOnWriteArrayList, є в Java/Android і використовуються для уникнення проблем, пов'язаних з одночасним доступом до колекцій з різних потоків.",
              "Такі колекції забезпечують синхронізацію на рівні окремих операцій або блокують доступ до всієї структури під час модифікації."
            ]
          },
          {
            "questionText": "Які стратегії можна застосувати, щоб досягти потокобезпеки?",
            "answerItems": [
              "Синхронізація: Використання ключового слова 'synchronized' для синхронізації методів або блоків коду.",
              "Атомарні змінні: Використання атомарних класів, таких як AtomicInteger, для безпечного виконання операцій зі змінними.",
              "Неблокуючі алгоритми: Використання алгоритмів, які не використовують блокування для досягнення потокобезпеки, наприклад, через порівняння і обмін (CAS)."
            ]
          },
          {
            "questionText": "Які варіанти реалізації потокобезпеки коду є в Kotlin?",
            "answerItems": [
              "В Kotlin існують різні варіанти реалізації потокобезпеки коду, аналогічні до Java:",
              "1. Синхронізація: Kotlin підтримує ключове слово 'synchronized' для використання в методах чи блоках коду для забезпечення потокобезпеки.",
              "2. Використання потокобезпечних колекцій: Kotlin може використовувати потокобезпечні колекції, такі як 'ConcurrentHashMap', 'ConcurrentLinkedQueue', для безпечної роботи з даними в багатьох потоках.",
              "3. Використання корутин (Coroutines): Kotlin надає корутини для асинхронного програмування та управління потоками. Вони дозволяють зручно управляти виконанням коду в різних потоках без необхідності блокувати потоки."
            ]
          },
          {
            "questionText": "Як зробити змінну потокобезпечною?",
            "answerItems": [
              "Для забезпечення потокобезпеки змінній можна використовувати ключове слово 'volatile' для забезпечення видимості змінної між потоками.",
              "Також можна використовувати синхронізацію, наприклад, блоки 'synchronized' чи корутини для правильного доступу до змінних в багатьох потоках."
            ]
          },
          {
            "questionText": "Що таке Mutex та Monitor? Хто може виступати в ролі монітора?",
            "answerItems": [
              "Mutex (взаємовиключення) та Monitor (монітор) - це механізми синхронізації, які використовуються для забезпечення потокобезпеки в багатьох мовах програмування, включаючи Kotlin.",
              "Mutex - це блокувальний об'єкт, який може бути захоплений одним потоком наразі. Він використовується для блокування доступу до критичних ресурсів.",
              "Monitor - це абстрактний патерн синхронізації, який може включати в себе mutex. В Kotlin, 'synchronized' блоки використовують монітори для синхронізації доступу до ресурсів.",
              "Хто може виступати в ролі монітора залежить від контексту. Зазвичай це може бути об'єкт, до якого потрібно заблокувати доступ для інших потоків."
            ]
          },
          {
            "questionText": "Що таке атомарні операції?",
            "answerItems": [
              "Атомарні операції - це операції, які виконуються як єдине ціле і не можуть бути розбиті на менші операції, які виконуються іншими потоками паралельно.",
              "Це означає, що під час виконання атомарних операцій інші потоки не можуть втручатися та змінювати значення операції напівпроміжності, що гарантує їхню консистентність."
            ]
          },
          {
            "questionText": "Чому інкрементація та операції з long не є атомарними?",
            "answerItems": [
              "Інкрементація та операції з long не є атомарними в деяких випадках через їхню реалізацію в архітектурі процесора. На деяких архітектурах процесора операція інкрементації або операції з long можуть вимагати декілька інструкцій, і в цей час інші потоки можуть втручатися і змінювати значення, що призводить до некоректних результатів.",
              "Для забезпечення атомарності таких операцій в Java і Kotlin існують спеціальні класи, такі як 'AtomicInteger', 'AtomicLong', які використовують вбудовані механізми атомарних операцій у різних архітектурах процесора."
            ]
          },
          {
            "questionText": "Які є класи атомарних змінних?",
            "answerItems": [
              "У Java і Kotlin існують класи для роботи з атомарними змінними, які включають:",
              "- 'AtomicInteger' та 'AtomicLong' для атомарних цілих чисел;",
              "- 'AtomicReference' для атомарної посилання на об'єкт;",
              "- 'AtomicBoolean' для атомарних булевих значень;",
              "- Та інші, які надають атомарні операції для різних типів даних."
            ]
          },
          {
            "questionText": "Що таке застарілі дані (stale data)? Як уникнути цього ефекту?",
            "answerItems": [
              "Застарілі дані (stale data) - це дані, які можуть бути невірними або застарілими через одночасні зміни в різних потоках.",
              "Щоб уникнути цього ефекту, можна використовувати синхронізацію, атомарні операції та потокобезпечні колекції.",
              "Також можна використовувати правильну стратегію зчитування та запису даних з атомарними операціями, щоб забезпечити консистентність та уникнути застарілих даних."
            ]
          }
        ]
      },
      {
        "topic": "Java Core",
        "questions": [
          {
            "questionText": "Механізм Generics. Яку проблему розв’язує?",
            "answerItems": [
              "Механізм Generics в Java дозволяє створювати класи, інтерфейси і методи, які можуть працювати з параметризованими типами даних. Він дозволяє визначити клас або метод, який буде працювати з будь-яким типом даних, і вказати цей тип при використанні.",
              "Основна проблема, яку розв'язує Generics, - це поліморфізм з параметрами. Він дозволяє писати загальні інструкції і алгоритми, які можна використовувати для різних типів даних без дублювання коду."
            ]
          },
          {
            "questionText": "Що таке soft reference, weak reference?",
            "answerItems": [
              "У Java є два типи посилань, які допомагають в управлінні пам'яттю: 'soft reference' і 'weak reference'.",
              "Soft Reference - це посилання на об'єкт, який буде збережений в пам'яті до тих пір, поки пам'ять не стане критичною. Якщо пам'ять стає критичною, JVM може видалити об'єкти, на які вказують soft references.",
              "Weak Reference - це посилання на об'єкт, який буде видалений з пам'яті, якщо на нього немає сильних (strong) посилань. Weak references використовуються, наприклад, для реалізації кешу, де об'єкти можуть бути видалені, якщо пам'ять стає критичною."
            ]
          },
          {
            "questionText": "Що таке серіалізація об’єкта? Яку проблему вона вирішує? Які є стандартні механізми у Java?",
            "answerItems": [
              "Серіалізація об'єкта в Java - це процес перетворення об'єкта в потік байтів, щоб його можна було зберегти на диску або передати через мережу. Вона дозволяє зберігати та відновлювати стан об'єкта після його серіалізації та десеріалізації.",
              "Проблему, яку вирішує серіалізація, - це збереження стану об'єкта для подальшого відновлення. Це корисно для зберігання даних або передачі об'єктів через мережу.",
              "У Java для серіалізації об'єктів використовується механізм Java Serialization, який дозволяє позначити класи як серіалізовані за допомогою інтерфейсу 'Serializable'. Також можна використовувати зовнішні бібліотеки, такі як Jackson, Gson, для серіалізації в JSON форматі."
            ]
          },
          {
            "questionText": "Який контракт існує між equals() та hashCode()?",
            "answerItems": [
              "Між методами 'equals()' та 'hashCode()' існує важливий контракт в Java:",
              "- Якщо 'equals()' повертає 'true' для двох об'єктів, то їхні 'hashCode()' повинні бути однаковими.",
              "- Проте обернена вимога не обов'язкова: два об'єкти з однаковим 'hashCode()' не обов'язково повинні бути рівними за 'equals()'.",
              "Цей контракт важливий для коректної роботи об'єктів в колекціях, таких як 'HashSet' або 'HashMap'."
            ]
          },
          {
            "questionText": "На вашу думку, чому рядки в Java зроблено імутабельними?",
            "answerItems": [
              "Рядки в Java зроблено імутабельними з декількох причин:",
              "- Безпека: Імутабельні рядки гарантують, що їхні значення не можуть бути змінені, тому вони можуть безпечно використовуватися в багатьох потоках без синхронізації.",
              "- Кешування: Імутабельні рядки можна кешувати, що дозволяє ефективно використовувати пам'ять для повторюваних рядків.",
              "- Передача по значенню: Імутабельні рядки передаються по значенню, що дозволяє уникнути побічних ефектів при їх використанні."
            ]
          },
          {
            "questionText": "Чи можемо ми задекларувати порожній інтерфейс? Якщо так, то навіщо?",
            "answerItems": [
              "Так, в Java можна задекларувати порожній інтерфейс, тобто інтерфейс без жодного методу. Це називається 'маркерним інтерфейсом' або 'теговим інтерфейсом'.",
              "Порожні інтерфейси використовуються для позначення класів, які мають певні характеристики чи функціональність. Наприклад, 'Serializable' - це порожній інтерфейс, який вказує, що клас може бути серіалізований. Вони допомагають в управлінні інформацією про класи та їх можливостями."
            ]
          },
          {
            "questionText": "Що таке String pool? Для чого він?",
            "answerItems": [
              "String pool - це механізм внутрішнього кешування рядків в Java, який зберігає однакові рядки в одному екземплярі в пам'яті. Він призначений для оптимізації використання пам'яті та прискорення порівняння рядків.",
              "Коли ви створюєте рядок за допомогою літерала, наприклад, 'String s = \"Hello\";', Java спочатку перевіряє String pool на наявність такого рядка. Якщо він вже там є, видається посилання на існуючий екземпляр. Якщо немає, створюється новий екземпляр і додається в String pool.",
              "String pool допомагає економити пам'ять та підвищувати продуктивність за рахунок уникнення створення зайвих копій рядків."
            ]
          },
          {
            "questionText": "Що таке StringBuilder, яку проблему він розв’язує?",
            "answerItems": [
              "StringBuilder - це клас в Java, який використовується для збудування та модифікації рядків. Він дозволяє ефективно працювати з рядками, які можуть змінюватися, без створення нових об'єктів рядків при кожній операції зміни.",
              "Проблему, яку він розв'язує, - це ефективне створення та модифікація рядків без зайвого використання пам'яті. В порівнянні зі звичайним 'String', який є імутабельним і створює новий об'єкт при кожній модифікації, 'StringBuilder' працює швидше і використовує менше пам'яті, особливо при великих об'ємах даних."
            ]
          },
          {
            "questionText": "Що таке Stack у JVM та які дані там зберігаються?",
            "answerItems": [
              "Stack - це одна з основних структур даних в JVM (Java Virtual Machine), яка використовується для управління викликами методів та зберігання даних локальних змінних методів.",
              "У Stack зберігається інформація про виклик методів, параметри цих методів, адреси повернення та локальні змінні методу. Кожен потік виконання має свій власний стек викликів методів."
            ]
          },
          {
            "questionText": "Що таке Heap у JVM та які дані там зберігаються?",
            "answerItems": [
              "Heap - це область пам'яті в JVM, в якій зберігаються об'єкти та дані, до яких можна отримати доступ з будь-якого місця програми. В Heap зберігаються всі об'єкти, створені в програмі.",
              "У Heap знаходяться об'єкти, які не мають життєвого циклу, обмеженого областю дії одного методу або потоку. До них можна звертатися з різних частин програми та вони існують до тих пір, поки на них є посилання."
            ]
          },
          {
            "questionText": "Що таке garbage collector, як він загалом працює? Які є реалізації GC?",
            "answerItems": [
              "Garbage Collector (GC) - це механізм в JVM, який автоматично видаляє об'єкти, які стали недоступними та більше не використовуються програмою, для звільнення пам'яті.",
              "Робота GC полягає в виявленні об'єктів, які більше не можуть бути досягнуті програмою (сміття) та видаленні їх. Це допомагає уникнути витоку пам'яті та забезпечити ефективне використання ресурсів.",
              "Існують різні реалізації GC в JVM, такі як G1 (Garbage-First), CMS (Concurrent Mark-Sweep), Parallel GC, ZGC, Shenandoah та інші. Кожна з них має свої переваги та недоліки і може бути вибрана в залежності від конкретних потреб програми."
            ]
          }
        ]
      },
      {
        "topic": "Android SDK",
        "questions": [
          {
            "questionText": "Назвіть основні зміни у версіях Android.",
            "answerItems": [
              "Основні зміни у версіях Android включають:",
              "- Зміни у користувацькому інтерфейсі (UI), такі як різні версії Material Design, введення жестів, роздільний екран, темну та світлу теми.",
              "- Удосконалення продуктивності та оптимізація пам'яті.",
              "- Введення нових API та функціональностей, наприклад, покращена система навігації, розширені можливості камери, покращені механізми безпеки.",
              "- Підтримка нових архітектур та пристроїв, таких як 64-бітні процесори, сенсори відбитків пальців, розгорнута підтримка NFC.",
              "- Зміни у розробницькому інструментарії, такі як Android Studio, Kotlin як офіційна мова програмування, Android Jetpack бібліотеки для полегшення розробки."
            ]
          },
          {
            "questionText": "Як реалізувати IPC в системі Android?",
            "answerItems": [
              "IPC (Inter-Process Communication) в Android дозволяє обмінюватися даними та взаємодіяти між різними процесами. Для реалізації IPC в системі Android можна використовувати наступні методи:",
              "- Intent: Він дозволяє запустити компоненти (Activity, Service) в іншому процесі за допомогою Intent.",
              "- Binders: Використовується для виклику методів інших служб, які надають відповідний інтерфейс.",
              "- Messenger: Дозволяє створити об'єкт Messenger для обміну повідомленнями між різними процесами.",
              "- Content Providers: Дозволяє забезпечити спільний доступ до даних між додатками через URI.",
              "- AIDL (Android Interface Definition Language): Використовується для визначення інтерфейсів між процесами та генерації коду для забезпечення віддаленого виклику методів."
            ]
          },
          {
            "questionText": "Як реалізувати відкладену задачу?",
            "answerItems": [
              "Для реалізації відкладеної задачі в Android можна використовувати клас 'Handler' або 'AsyncTask', а також більш сучасні підходи, такі як 'ThreadPoolExecutor' або 'RxJava'.",
              "За допомогою класу 'Handler' можна створити об'єкт, який взаємодіє з основним потоком і виконує задачі після певного часу або через певні інтервали.",
              "'AsyncTask' дозволяє виконувати фонові операції та оновлювати UI в головному потоці.",
              "'ThreadPoolExecutor' дозволяє створювати пул потоків для виконання відкладених задач.",
              "'RxJava' - це бібліотека для реактивного програмування, яка дозволяє створювати та обробляти потоки подій, включаючи відкладені задачі."
            ]
          },
          {
            "questionText": "Що таке Doze Mode?",
            "answerItems": [
              "Doze Mode - це функція в Android, яка запускається на пристроях з Android 6.0 та вище для зменшення споживання енергії в режимі очікування.",
              "У режимі Doze Mode пристрій обмежує синхронізацію даних, відключає додатки з мережі та обмежує активність апаратних компонентів для збереження заряду батареї. Він активується, коли пристрій не використовується тривалий час."
            ]
          },
          {
            "questionText": "Що таке App Standby mode?",
            "answerItems": [
              "App Standby mode - це функція в Android, яка обмежує активність додатків в режимі очікування для збереження заряду батареї.",
              "У режимі App Standby додатки, які не були використані тривалий час, мають обмежений доступ до ресурсів пристрою, таких як мережа та CPU. Це допомагає зменшити споживання енергії та продовжити час роботи пристрою в режимі очікування."
            ]
          },
          {
            "questionText": "Що таке AIDL та для чого він? Які типи даних підтримуються?",
            "answerItems": [
              "AIDL (Android Interface Definition Language) - це мова опису інтерфейсів, яка використовується для визначення інтерфейсів між процесами в Android.",
              "AIDL дозволяє створювати інтерфейси для виклику методів одного процесу з іншого процесу. Це корисно для реалізації IPC (Inter-Process Communication) в Android.",
              "AIDL підтримує передачу примітивних типів даних, об'єктів 'Parcel', списків та інших об'єктів, які можуть бути серіалізовані."
            ]
          },
          {
            "questionText": "Що таке Multidex?",
            "answerItems": [
              "Multidex - це механізм в Android, який дозволяє додаткам мати більше одного файлу DEX (Dalvik Executable) для вмісту байткоду.",
              "Це особливо корисно, коли додаток має велику кількість класів та методів, які не поміщаються в один DEX-файл. Multidex дозволяє розподілити байткод додатку на декілька файлів DEX, що допомагає уникнути перевищення обмежень для кількості методів в одному DEX-файлі."
            ]
          },
          {
            "questionText": "Що таке KeyStore API?",
            "answerItems": [
              "KeyStore API - це API в Android, яке дозволяє зберігати та керувати ключами та сертифікатами, використовуваними для шифрування та підпису даних в застосунках.",
              "За допомогою KeyStore API можна створювати та керувати ключами, зберігати їх у безпечному сховищі, використовувати для різних шифрувальних та підписових операцій. Він допомагає забезпечити безпеку даних в Android-застосунках."
            ]
          },
          {
            "questionText": "Що таке PendingIntent?",
            "answerItems": [
              "PendingIntent - це обгортка над інтентом (Intent) в Android, яка дозволяє створювати та передавати дії, які мають виконатися в майбутньому, в інший компонент додатку або навіть в інший додаток.",
              "PendingIntent дозволяє запустити дії, такі як запуск активності, служби або відправлення мовлення, в контексті, який не обов'язково пов'язаний з контекстом виклику. Він корисний для реалізації різних функцій, таких як сповіщення, будильники та інші асинхронні дії."
            ]
          },
          {
            "questionText": "Як безпечно зберігати user-sensitive дані?",
            "answerItems": [
              "Для безпечного зберігання user-sensitive даних в Android рекомендується використовувати наступні методи:",
              "- Використання KeyStore API для зберігання ключів та сертифікатів.",
              "- Використання EncryptedSharedPreferences для шифрування налаштувань.",
              "- Використання Android Keystore для зберігання ключів та даних в безпечному сховищі.",
              "- Використання BiometricPrompt для біометричної автентифікації користувача перед доступом до чутливих даних."
            ]
          },
          {
            "questionText": "Які є методи захисту застосунку?",
            "answerItems": [
              "Захист застосунку в Android включає в себе наступні методи:",
              "- Використання Android Permissions для обмеження доступу до ресурсів та даних.",
              "- Використання ProGuard або R8 для зменшення розміру та захисту від зворотного інжинірингу.",
              "- Використання HTTPS для захисту комунікації з серверами.",
              "- Використання Android App Bundles для розповсюдження застосунку, який містить тільки необхідні ресурси для конкретного пристрою.",
              "- Перевірка на вразливості та використання OWASP Mobile Top Ten для виявлення та усунення потенційних проблем безпеки."
            ]
          },
          {
            "questionText": "Що таке SSL/TLS Pinning? Як його реалізувати в Android?",
            "answerItems": [
              "SSL/TLS Pinning - це метод безпеки, який дозволяє застосунку перевіряти, чи використовується конкретний сертифікат сервера під час SSL/TLS з'єднання. Це допомагає запобігти MITM-атакам (Man-in-the-Middle).",
              "Для реалізації SSL/TLS Pinning в Android, потрібно отримати публічний ключ сервера та вручну перевіряти його в коді застосунку. Можна використовувати бібліотеки, такі як OkHttp, для легкості реалізації цього методу безпеки."
            ]
          },
          {
            "questionText": "Що таке ViewBinding?",
            "answerItems": [
              "ViewBinding - це бібліотека в Android, яка дозволяє легко звертатися до елементів користувацького інтерфейсу (View) в XML-файлах без необхідності використання 'findViewById'.",
              "ViewBinding автоматично генерує зв'язки між елементами інтерфейсу та Java/Kotlin-кодом, що полегшує роботу з UI та зменшує ризик помилок через неправильні ID."
            ]
          },
          {
            "questionText": "Для чого методи onSaveInstanceState/onRestoreInstanceState? Що таке permissions? Як зробити запит permissions?",
            "answerItems": [
              "Методи onSaveInstanceState та onRestoreInstanceState використовуються для збереження та відновлення стану активності під час зміни конфігурації або при знищенні та пересозданні активності.",
              "Permissions - це дозволи, які дають застосунку доступ до різних ресурсів та функціональностей пристрою, таких як камера, мікрофон, контакти, місцезнаходження та інші.",
              "Для запиту permissions в Android, потрібно використовувати системний діалоговий вікно запиту дозволу, яке дозволяє користувачу надати або відмовити доступ до певного ресурсу. Для цього використовуються методи 'requestPermissions' та 'onRequestPermissionsResult'."
            ]
          },
          {
            "questionText": "Що таке Intent? Що таке Explicit/Implicit Intent? Що таке Sticky Intent, Pending Intent?",
            "answerItems": [
              "Intent - це об'єкт, який використовується для взаємодії між компонентами Android, такими як активності, служби, приймачі та інші. Він вказує дію, яку слід виконати, та може містити дані для передачі між компонентами.",
              "Explicit Intent - це Intent, який конкретно вказує компонент, з яким потрібно взаємодіяти, за допомогою імені компонента (пакету та класу).",
              "Implicit Intent - це Intent, який не вказує конкретного компонента, а лише описує дію, яку потрібно виконати, і система обирає підходящий компонент для виконання цієї дії на основі фільтрів Intents у зареєстрованих додатках.",
              "Sticky Intent - це Intent, який може залишитися в системі та чекати, поки його обробить компонент, навіть після того, як компонент, який мав його обробити, закритий.",
              "Pending Intent - це обгортка для Intent, який може бути відправлений та виконаний в майбутньому. Використовується для реалізації відкладених дій, таких як запуск активності або служби після певної події."
            ]
          },
          {
            "questionText": "Які типи даних ми можемо покласти у Bundle?",
            "answerItems": [
              "У Bundle можна покласти різні типи даних, такі як:",
              "- Примітивні типи даних (int, boolean, float, тощо).",
              "- Строки (String).",
              "- Масиви примітивних типів даних.",
              "- Об'єкти, які реалізують інтерфейс Serializable або Parcelable.",
              "- Інші об'єкти, які можна серіалізувати або Parcelable, якщо використовується Binder для міжпроцесової комунікації."
            ]
          },
          {
            "questionText": "У чому різниця між Serializable та Parcelable?",
            "answerItems": [
              "Serializable та Parcelable - це два способи серіалізації об'єктів для передачі між компонентами Android або зберігання в стані бандла:",
              "- Serializable - це стандартний механізм Java для серіалізації об'єктів, який перетворює об'єкт в байти та дозволяє його відновити. Використовується в Java-застосунках.",
              "- Parcelable - це інтерфейс, спеціально розроблений для Android, який дозволяє серіалізувати об'єкти більш ефективно та швидко, особливо для передачі між процесами. Parcelable зазвичай є більш швидким та ефективним варіантом для Android-застосунків."
            ]
          },
          {
            "questionText": "Якщо фрагмент для роботи потребує вхідних даних, яким чином буде правильно передати їх фрагменту?",
            "answerItems": [
              "Для передачі вхідних даних фрагменту можна використовувати конструктор фрагмента та методи 'setArguments' та 'getArguments'.",
              "1. Створити Bundle, додати до нього потрібні дані.",
              "2. Використати метод 'setArguments' для передачі Bundle фрагменту під час його створення.",
              "3. У фрагменті використовувати метод 'getArguments' для отримання Bundle та отримання даних з нього."
            ]
          },
          {
            "questionText": "Що таке ViewModel? Які її властивості?",
            "answerItems": [
              "ViewModel - це компонент архітектури Jetpack, який призначений для зберігання та управління даними, пов'язаними з інтерфейсом користувача (UI) в Android-застосунках.",
              "Основні властивості ViewModel:",
              "- Виживає при зміні конфігурації (наприклад, при повороті екрану), тобто дані не втрачаються.",
              "- Всі дані, які потрібні для певного екрану або компонента, зберігаються в ViewModel.",
              "- ViewModel не залежить від життєвого циклу активності чи фрагмента, і це дозволяє уникнути витоку ресурсів та інших проблем, пов'язаних з життєвим циклом."
            ]
          },
          {
            "questionText": "Поясніть роботу ViewModel з Jetpack. Що таке ViewModelProviders, ViewModelProvider.Factory?",
            "answerItems": [
              "ViewModel з Jetpack дозволяє зберігати та управляти даними між конфігураціями та компонентами, які належать до одного життєвого циклу.",
              "ViewModelProviders - це клас, який надає зручний спосіб отримання ViewModel у компонентах, таких як активності та фрагменти. Він дозволяє створювати або отримувати існуючу ViewModel для певного класу ViewModel.",
              "ViewModelProvider.Factory - це інтерфейс, який можна використовувати для створення або перевизначення створення ViewModel. Це дозволяє керувати тим, як ViewModel ініціалізується та зберігається."
            ]
          },
          {
            "questionText": "Що таке LiveData? Для чого її використовуєте?",
            "answerItems": [
              "LiveData - це компонент архітектури Jetpack, який надає спостережливі дані, які автоматично оновлюються, коли їх джерело змінюється.",
              "LiveData використовується для спрощення оновлення інтерфейсу користувача (UI) на основі даних. Вона автоматично повідомляє підписників про зміни та гарантує, що дані оновлюються в потоці інтерфейсу користувача (головному потоці). LiveData допомагає уникнути проблем, пов'язаних з неправильним доступом до даних з різних потоків."
            ]
          },
          {
            "questionText": "Який зв’язок між LiveData та LifecycleOwner?",
            "answerItems": [
              "LiveData пов'язана з LifecycleOwner, таким як активність чи фрагмент. Вона автоматично враховує життєвий цикл власника і припиняє сповіщення про зміни, коли власник не активний або більше не потрібен.",
              "Це допомагає уникнути ситуацій, коли активність чи фрагмент намагається оновлювати свій інтерфейс користувача, коли він вже був знищений або не активний, що може призвести до витоку ресурсів та помилок."
            ]
          },
          {
            "questionText": "Наведіть приклад LifecycleOwner?",
            "answerItems": [
              "Приклади LifecycleOwner включають активності (Activity) та фрагменти (Fragment). Вони реалізують інтерфейс LifecycleOwner та надають життєвий цикл для компонентів інтерфейсу користувача."
            ]
          },
          {
            "questionText": "Що таке Looper?",
            "answerItems": [
              "Looper - це частина архітектури Android, яка дозволяє обробляти повідомлення та завдання в потоках. Кожен потік має свій власний Looper, який використовується для обробки повідомлень, які надходять до потока."
            ]
          },
          {
            "questionText": "Чи використовували HaMeR фреймворк (Handler/Message/Runnable)? Навіщо він?",
            "answerItems": [
              "Так, HaMeR фреймворк (Handler/Message/Runnable) широко використовується в Android для взаємодії зі спеціальними потоками, такими як UI-потік. Він дозволяє виконувати дії асинхронно та змінювати UI з інших потоків.",
              "Головна його задача - надсилання повідомлень (Message) через Handler у потік UI, де вони можуть бути оброблені. Використовується для запуску задач або обміну даними між різними потоками."
            ]
          },
          {
            "questionText": "Яку інформацію містить контекст? Які типи контексту знаєте?",
            "answerItems": [
              "Контекст (Context) містить інформацію про поточний стан додатка та дозволяє взаємодіяти з різними системними ресурсами та функціями пристрою.",
              "Типи контексту включають:",
              "- ApplicationContext: Глобальний контекст додатка, який доступний на протязі усього життєвого циклу додатка.",
              "- ActivityContext: Контекст, пов'язаний з конкретною активністю (Activity), який може бути використаний для взаємодії з UI та ресурсами активності.",
              "- ServiceContext: Контекст, пов'язаний зі службою (Service), який може бути використаний для взаємодії з фоновими службами."
            ]
          },
          {
            "questionText": "Для чого використовують Content Provider?",
            "answerItems": [
              "Content Provider використовуються для надання доступу до даних додатків іншим додаткам. Вони дозволяють додаткам обмінюватися даними за допомогою URI-запитів та визначають доступ до даних через CRUD-операції (створення, читання, оновлення, видалення).",
              "Content Provider також використовуються для збереження та розділення даних між різними компонентами додатку, такими як активності, служби та приймачі."
            ]
          },
          {
            "questionText": "Що таке Data Binding? Що таке View Binding?",
            "answerItems": [
              "Data Binding - це бібліотека, яка дозволяє зв'язувати дані між моделлю даних і UI автоматично. Вона дозволяє писати більш читабельний та підтримуваний код для роботи з UI.",
              "View Binding - це інший підхід, який дозволяє легко отримувати доступ до елементів інтерфейсу користувача (View) з XML-файлів без необхідності використання 'findViewById'. Він також сприяє зменшенню можливих помилок через неправильні ID."
            ]
          },
          {
            "questionText": "Переваги Fragments проти View?",
            "answerItems": [
              "Fragments та View мають різні використання та переваги в залежності від потреб додатку:",
              "- Fragments дозволяють створювати більш складні та переносимі компоненти інтерфейсу, які можна повторно використовувати в різних активностях.",
              "- Fragments можуть бути динамічно додаваними та видалятися в робочому часі, що дозволяє реалізувати більш динамічний UI.",
              "- View можуть бути простими та зручними для простих елементів інтерфейсу, і вони можуть бути використані в межах однієї активності."
            ]
          },
          {
            "questionText": "Як працює Content Provider?",
            "answerItems": [
              "Content Provider працює як посередник між додатком та даними, надаючи доступ до даних через URI-запити. Він визначає доступ до даних через CRUD-операції (створення, читання, оновлення, видалення) та виконує ці операції над реальними даними, які зберігаються в базі даних або інших джерелах.",
              "Content Provider використовує URI для ідентифікації ресурсів та запитів до них. Інші додатки можуть отримувати доступ до даних, використовуючи ці URI-запити та правила доступу, які визначені в Content Provider.",
              "Це дозволяє ділитися даними між різними додатками та компонентами Android, такими як активності, служби та приймачі."
            ]
          },
          {
            "questionText": "Яка різниця між Single Activity та Multiple Activity?",
            "answerItems": [
              "Single Activity - це підхід до розробки Android-додатків, де весь UI реалізується в одній активності, а решта екранів відображаються як фрагменти. Головною перевагою цього підходу є зменшення кількості активностей та покращення навігації, що може покращити продуктивність та об'єднати всі компоненти додатку.",
              "Multiple Activity - це традиційний підхід, де кожна екранна сторінка додатку реалізується у власній активності. Цей підхід підходить для додатків зі складним UI та вимагає більшої кількості активностей та навігаційних операцій."
            ]
          },
          {
            "questionText": "Які види Context знаєте, де який використовувати?",
            "answerItems": [
              "В Android існують різні види Context, такі як:",
              "- ApplicationContext: Використовується для доступу до ресурсів та функцій додатка на рівні додатка, доступний на протязі усього життєвого циклу додатка.",
              "- ActivityContext: Використовується для доступу до ресурсів та функцій конкретної активності, використовується для взаємодії з UI та функціями активності.",
              "- ServiceContext: Використовується у службах для доступу до ресурсів та функцій служби.",
              "Користувач повинен вибирати контекст відповідно до потреб додатка та області його використання, щоб уникнути можливих проблем та витоків ресурсів."
            ]
          },
          {
            "questionText": "Поясніть роботу BroadcastReceiver і його реалізацію.",
            "answerItems": [
              "BroadcastReceiver - це компонент Android, який дозволяє додаткам приймати та обробляти повідомлення (broadcasts) від інших додатків чи системи. Він дозволяє додаткам реагувати на події, такі як зміна стану мережі, прихід SMS або інші системні події.",
              "Реалізація BroadcastReceiver включає наступні кроки:",
              "- Створення підкласу BroadcastReceiver і перевизначення методу 'onReceive()', де визначається логіка обробки повідомлень.",
              "- Реєстрація BroadcastReceiver у додатку за допомогою 'registerReceiver()' або у маніфесті за допомогою елемента '<receiver>'.",
              "- Приймання та обробка повідомлень в методі 'onReceive()' залежно від типу повідомлення та потреб додатку."
            ]
          },
          {
            "questionText": "Навіщо LocalBroadcastManager?",
            "answerItems": [
              "LocalBroadcastManager - це клас, який дозволяє відправляти та приймати локальні повідомлення (broadcasts) в межах одного додатка. Він є частиною підсистеми Android для спілкування між компонентами додатку та дозволяє реалізувати ефективну комунікацію між компонентами без необхідності використання системних повідомлень.",
              "LocalBroadcastManager корисний для спрощення внутрішнього спілкування між компонентами додатку, але він не підходить для взаємодії між різними додатками, оскільки він обмежений областю видимості додатку."
            ]
          },
          {
            "questionText": "Для чого потрібен MotionLayout?",
            "answerItems": [
              "MotionLayout - це частина бібліотеки MotionLayout в Android, яка дозволяє створювати складні анімації та взаємодію між різними елементами інтерфейсу користувача. Він використовує XML-файли для визначення анімаційних переходів та поведінок елементів інтерфейсу користувача.",
              "MotionLayout дозволяє легко створювати анімації переміщення, зміни розміру, зміни положення елементів, а також взаємодію між ними. Він спрощує процес створення складних анімацій та візуальних ефектів в додатках Android."
            ]
          },
          {
            "questionText": "Опишіть, як реалізувати анімацію в MotionLayout.",
            "answerItems": [
              "Анімація в MotionLayout реалізується за допомогою ключових кадрів (keyframes) та констрейнів (constraints). Основні кроки реалізації анімації включають:",
              "- Визначення початкового та кінцевого стану елементів інтерфейсу користувача в XML-файлі.",
              "- Визначення ключових кадрів (keyframes), де задається зміна параметрів елементів у різні моменти часу.",
              "- Встановлення констрейнів (constraints) для елементів, що вказують, як їх положення і розміри змінюються в часі.",
              "- Використання TransitionManager для створення переходів між станами та запуску анімації.",
              "MotionLayout надає можливість створювати складні анімації, які реагують на жести користувача або зміни стану додатку."
            ]
          },
          {
            "questionText": "Як можна виявити проблеми у швидкості UI та усунути їх?",
            "answerItems": [
              "Виявлення та вирішення проблем у швидкості UI включає в себе наступні кроки:",
              "- Використання інструментів профілювання, таких як Android Profiler, для вимірювання продуктивності додатку та виявлення гарячих точок.",
              "- Оптимізація алгоритмів та операцій, які займають багато часу в головному потоці (UI-потоці).",
              "- Використання асинхронних операцій, таких як завантаження даних або обробка зображень, в окремих потоках.",
              "- Зменшення кількості та складності відомостей, які передаються між компонентами додатку.",
              "- Використання кешування та пулінгу ресурсів для зменшення навантаження на системні ресурси."
            ]
          },
          {
            "questionText": "Розкажіть про варіанти реалізації custom view.",
            "answerItems": [
              "Варіанти реалізації custom view в Android включають наступні підходи:",
              "- Створення підкласу класу View або його підкласу (наприклад, ImageView або TextView) та перевизначення методів 'onDraw()' для малювання власного вигляду.",
              "- Використання підкласу класу ViewGroup (наприклад, RelativeLayout або LinearLayout) для створення власного макету та розміщення на ньому елементів власного вигляду.",
              "- Використання бібліотеки Jetpack Compose для опису інтерфейсу користувача у вигляді коду замість XML-розмітки.",
              "Кожен з цих підходів має свої переваги та особливості, і вибір залежить від конкретних потреб додатку та ваших вмінь у розробці."
            ]
          },
          {
            "questionText": "Що роблять методи onMeasure, onLayout, onDraw в View?",
            "answerItems": [
              "Методи onMeasure, onLayout та onDraw в View відповідають за різні аспекти роботи з виглядом:",
              "- onMeasure: Цей метод визначає розмір і розміщення елемента в контейнері. Він викликається перед відображенням елемента та визначає, скільки місця займе елемент на екрані.",
              "- onLayout: Цей метод встановлює фактичну позицію елемента на екрані, враховуючи розмір та розташування батьківського контейнера. Він визначає, де саме буде відображено елемент.",
              "- onDraw: Цей метод відповідає за малювання зображення елемента на екрані. Він викликається при кожному оновленні екрану та дозволяє відобразити вміст елемента, включаючи текст, графіку, форми тощо."
            ]
          },
          {
            "questionText": "Як реалізувати анімацію при переході між Activity-фрагментами?",
            "answerItems": [
              "Анімація при переході між Activity-фрагментами може бути реалізована різними способами:",
              "- Використання анімаційних ресурсів та переходів у макетах XML для визначення анімації при зміні фрагментів.",
              "- Використання анімаційних об'єктів (Animator) та API анімацій для створення власних анімацій при переході.",
              "- Використання бібліотеки Jetpack Navigation для автоматизації анімацій при переходах між фрагментами.",
              "Вибір способу залежить від складності та потреб додатку, а також від ваших знань у галузі анімації."
            ]
          },
          {
            "questionText": "Коли необхідно використовувати foreground service замість service?",
            "answerItems": [
              "Foreground service використовується тоді, коли додаток виконує діяльність, яка важлива для користувача та вимагає постійного відображення інформації в сповіщенні на панелі сповіщень. Наприклад, це може бути музичний плеєр, який продовжує грати музику після закриття додатку або навігаційний сервіс, який відстежує розташування користувача під час навігації.",
              "Foreground service вимагає показу сповіщення з постійними оновленнями, що дозволяє користувачеві знати, що додаток виконує активну роботу. Service може використовуватися для фонових завдань, які не потребують відображення сповіщення користувачу та не вимагають постійного відслідковування."
            ]
          },
          {
            "questionText": "Коли використовувати WorkManager, а коли service?",
            "answerItems": [
              "Використання WorkManager або service залежить від конкретних потреб додатку:",
              "- WorkManager рекомендується використовувати для запланованих або повторюваних завдань, які можуть бути виконані з великою затримкою, навіть після перезапуску пристрою. Він забезпечує оптимальне керування ресурсами та може працювати в різних режимах, включаючи роботу при вимкненому екрані.",
              "- Service може бути використаний для простих фонових завдань, які не потребують запланованого виконання та можуть бути завершені швидко. Використання service може бути виправданим, коли потрібно виконати завдання без затримок та не вимагається повторювана робота.",
              "Обирайте між WorkManager та service в залежності від характеристик завдання та вимог до його виконання."
            ]
          },
          {
            "questionText": "Чи є у WorkManager ліміти на виконання роботи?",
            "answerItems": [
              "Так, у WorkManager є деякі ліміти на виконання роботи:",
              "- Робота в WorkManager може бути виконана з певними інтервалами, наприклад, кожні 15 хвилин або годину, і не може бути запущена частіше.",
              "- Максимальний час виконання одного завдання в WorkManager обмежений, і якщо завдання не завершиться в цей час, воно буде автоматично перезапущено.",
              "- WorkManager може відкладати виконання завдань, якщо є інші завдання в черзі, і вони займають всі доступні ресурси.",
              "Ці ліміти призначені для забезпечення стійкої роботи пристрою та ефективного використання ресурсів."
            ]
          },
          {
            "questionText": "Розкажіть про Jetpack Compose. Навіщо придумали, основний принцип роботи, як влаштовано?",
            "answerItems": [
              "Jetpack Compose - це сучасний і декларативний інтерфейсний фреймворк для створення користувацького інтерфейсу в додатках Android. Він призначений для спрощення розробки інтерфейсу, зменшення кількості бойлерплейту та забезпечення більшої гнучкості у створенні UI.",
              "Основний принцип роботи Jetpack Compose - це опис інтерфейсу у вигляді коду, а не XML-розмітки. Розробник описує, як має виглядати UI в декларативному стилі, і Compose автоматично генерує відповідний інтерфейс. Це спрощує роботу з UI та дозволяє швидше створювати та змінювати інтерфейс користувача.",
              "Jetpack Compose також вбудовує підтримку сучасних функцій, таких як анімація, dark mode, клавіатурні події та багато інших. Він інтегрований з іншими компонентами Jetpack та стає дедалі популярнішим серед розробників Android-додатків."
            ]
          },
          {
            "questionText": "Що таке WakeLock?",
            "answerItems": [
              "WakeLock - це механізм в Android, який дозволяє утримувати пристрій у режимі бодрості (не дозволяє йому переходити в режим сну) навіть під час бездіяльності екрану або блокування клавіатури. Використовується для забезпечення того, що додаток може продовжувати виконувати певні функції або операції в фоновому режимі, навіть коли пристрій перебуває у стані сну.",
              "WakeLock дозволяє додаткам управляти життєвим циклом екрану та блокуванням, забезпечуючи потрібну продуктивність і взаємодію з користувачем в режимі очікування. Проте використання WakeLock потребує обережності, оскільку неправильне використання може споживати багато енергії і призводити до надмірного розряду батареї."
            ]
          },
          {
            "questionText": "Що таке AlarmManager? Які особливості роботи?",
            "answerItems": [
              "AlarmManager - це компонент Android, який дозволяє планувати та виконувати дії в майбутньому, навіть коли додаток не активний. Він використовується для реалізації різних завдань, таких як сповіщення, регулярна синхронізація даних або виконання фонових завдань.",
              "Основні особливості роботи AlarmManager включають:",
              "- Планування повторюваних або одноразових подій у майбутньому за допомогою інтентів.",
              "- Вибір різних типів часових інтервалів для виконання дій (наприклад, один раз, щогодини або щодня).",
              "- Запуск дій навіть у режимі сну пристрою.",
              "- Можливість запуску дій після перезавантаження пристрою (після відновлення життєвого циклу).",
              "AlarmManager дозволяє додаткам планувати та виконувати різноманітні дії в майбутньому, що робить його корисним для реалізації фонових задач та подій з певною регулярністю."
            ]
          }
        ]
      },
      {
        "topic": "Kotlin",
        "questions": [
          {
            "questionText": "Чим відрізняється робота з Exceptions у Kotlin та Java?",
            "answerItems": [
              "У Kotlin робота з винятками (exceptions) схожа на Java, але має свої особливості:",
              "- В Kotlin немає обов'язковості використовувати try-catch блок для обробки винятків. Винятки є опціональними, і ви можете обробляти їх, лише якщо хочете.",
              "- В Kotlin немає перехоплення контрольованих винятків (checked exceptions), як в Java. Всі винятки в Kotlin є неконтрольованими (unchecked) і не потребують обов'язкового оброблення або декларації у сигнатурі методу.",
              "- Kotlin надає спеціальний оператор 'throw', який дозволяє створювати та викидати винятки безпосередньо.",
              "- У Kotlin також існує блок 'finally', але він має інший синтаксис порівняно з Java.",
              "Загалом, Kotlin намагається зробити роботу з винятками більш простою та ефективною, але це може вимагати адаптації для розробників, звиклих до Java."
            ]
          },
          {
            "questionText": "Що таке платформні типи?",
            "answerItems": [
              "Платформні типи (platform types) - це типи даних у Kotlin, які не мають аннотації 'nullable' ('?') та не вказані явно як 'Any'. Такі типи можуть бути як nullable, так і non-nullable, і їх поведінка визначається контекстом використання.",
              "Платформні типи використовуються для інтеграції Kotlin з Java, де відсутня інформація про nullability. Це означає, що Kotlin не може гарантувати, чи може змінна мати значення null в Java, тому вона є платформним типом.",
              "Для роботи з платформними типами у Kotlin використовують спеціальні функції, які надають інформацію про nullability, такі як 'asNullable()' та 'asNotNullable()'."
            ]
          },
          {
            "questionText": "Що таке нелокальний return?",
            "answerItems": [
              "Нелокальний return - це ситуація в Kotlin, коли ви використовуєте ключове слово 'return' внутрішньої функції для повернення значення з більш зовнішньої функції, в якій ця внутрішня функція вкладена. Такий return може бути використаний для завершення роботи більш зовнішньої функції з помилкою або результатом, який потрібно повернути з внутрішньої функції.",
              "Це може бути корисним, коли вам потрібно обробити помилку або обробити результат на більш високому рівні, не відбираючи значення через всі вкладені функції."
            ]
          },
          {
            "questionText": "Для чого потрібні reified generics?",
            "answerItems": [
              "Reified generics - це можливість використовувати типи в дженеріках на рівні виконання (runtime). У стандартному Java-дженериках типи стираються під час компіляції і недоступні в режимі виконання, що обмежує можливості використання дженеріків для рефлексії та інших завдань.",
              "Reified generics дозволяють зберегти типову інформацію під час виконання і використовувати її для динамічної генерації коду, рефлексії та інших завдань, які вимагають інформації про типи на рівні виконання.",
              "У Kotlin ви можете використовувати reified generics за допомогою ключового слова 'reified' разом із типом в дженеріку у функціях inline. Це дозволяє створювати більш потужні та безпечні абстракції з використанням дженеріків."
            ]
          },
          {
            "questionText": "Яка різниця між Unit, Any, Nothing?",
            "answerItems": [
              "У Kotlin є кілька спеціальних типів:",
              "- 'Unit' - це тип, що представляє відсутність значення або результату функції. Він використовується, коли функція не повертає жодного значення, схожий на 'void' в Java.",
              "- 'Any' - це тип, який представляє будь-яке значення. Всі типи у Kotlin наслідуються від 'Any', і ви можете використовувати його для представлення будь-якого об'єкта.",
              "- 'Nothing' - це тип, який представляє ситуацію, коли функція завершується або викидає виняток, і нічого не повертає. Він використовується, коли функція завершується без повернення значення або коли відбувається недосяжна точка виконання.",
              "Ці типи допомагають узагальнити роботу зі значеннями та зробити код більш безпечним і зрозумілим."
            ]
          },
          {
            "questionText": "Розкажіть про функції вищого порядку, лямбда, функції, що можуть використовуватись як аргумент.",
            "answerItems": [
              "Функції вищого порядку (higher-order functions) - це функції, які приймають інші функції як аргументи або повертають їх як результат. У Kotlin це реалізується завдяки можливості передавати функції як параметри, зберігати їх у змінних і повертати з інших функцій.",
              "Лямбда-вирази - це короткий спосіб оголошення анонімних функцій, які можна передавати як аргументи функціям вищого порядку. Вони використовують синтаксис '{ параметри -> тіло функції }' і зазвичай коротше та зручніше для використання у порівнянні з оголошенням окремої функції.",
              "Функції, які можуть використовуватись як аргументи, називаються функціями з типом, який включає в себе сигнатуру функції, наприклад, '(Int) -> String' означає функцію, яка приймає ціле число і повертає рядок. Такі функції можна передавати у функції вищого порядку або зберігати у змінних."
            ]
          },
          {
            "questionText": "Що таке inline-модифікатор? Noinline?",
            "answerItems": [
              "Inline-модифікатор - це ключове слово в Kotlin, яке можна застосовувати до функцій. Цей модифікатор дозволяє вбудовувати код функції безпосередньо у викликуючий код, що допомагає уникнути накладних витрат на виклик функції та підвищує продуктивність, особливо в разі коротких функцій або лямбд.",
              "Noinline - це інший модифікатор для функцій, який вказує, що деякі з аргументів функції не можуть бути передані як лямбди, які будуть вбудовані (інлайн), і вони мають бути використані як звичайні об'єкти. Це дозволяє уникнути проблем, коли аргументи функції потрібно зберегти або передати як об'єкти замість вбудовування їх у виклик."
            ]
          },
          {
            "questionText": "Яка різниця між crossinline та noinline?",
            "answerItems": [
              "Crossinline - це модифікатор для лямбд, які передаються у функції вищого порядку. Він вказує, що лямбда-вираз не може використовувати 'return' для виходу з функції, в якій вона вбудована. Це допомагає уникнути плутанини та неправильностей у коді, оскільки лямбда може бути викликана пізніше поза контекстом виклику функції вищого порядку.",
              "Noinline, як описано в попередньому запитанні, вказує, що аргумент функції не може бути вбудований (інлайн)."
            ]
          },
          {
            "questionText": "Які типи конструкторів ви знаєте?",
            "answerItems": [
              "У Kotlin є кілька типів конструкторів:",
              "- Первинний конструктор (Primary constructor) - це конструктор, який оголошується разом з оголошенням класу і може містити параметри та ініціалізацію властивостей класу.",
              "- Вторинний конструктор (Secondary constructor) - це додатковий конструктор, який можна визначити в класі. Він використовує ключове слово 'constructor' та дозволяє визначити додаткові способи створення об'єктів класу.",
              "- Ініціалізація блоку (Initializer block) - це блок коду, який виконується при створенні об'єкта класу, і використовується для ініціалізації властивостей.",
              "Користувачі можуть використовувати як первинний, так і вторинний конструктори для створення об'єктів класу."
            ]
          },
          {
            "questionText": "Що таке Flow? Що таке SharedFlow?",
            "answerItems": [
              "Flow - це асинхронний потік даних у Kotlin, який представляє собою послідовність значень, що можуть бути відправлені та оброблені асинхронно. Він дозволяє легко вирішувати проблеми, пов'язані з асинхронним програмуванням, та пропонує чистий та зрозумілий спосіб робити асинхронні операції.",
              "SharedFlow - це підтип Flow, який дозволяє кільком споживачам отримувати значення з потоку. Він може бути використаний для створення спільного потоку даних між різними частинами програми, які мають доступ до цих даних."
            ]
          },
          {
            "questionText": "У чому різниця методів run, let, apply, also, with, use?",
            "answerItems": [
              "У Kotlin існують різні методи, які дозволяють виконувати дії над об'єктами та змінювати їх стан. Основні різниці між ними такі:",
              "- 'run' - виконує блок коду над об'єктом і повертає результат останнього виразу в цьому блоку. Використовується, коли потрібно виконати дії над об'єктом і повернути результат.",
              "- 'let' - виконує блок коду над об'єктом і повертає результат останнього виразу в цьому блоку. Використовується, коли потрібно обробити об'єкт і передати результат обробки.",
              "- 'apply' - виконує блок коду над об'єктом і повертає сам об'єкт, на якому була викликана ця функція. Використовується для налаштування об'єктів.",
              "- 'also' - виконує блок коду над об'єктом і повертає сам об'єкт, на якому була викликана ця функція. Використовується для додаткових дій над об'єктом, які не змінюють його стан.",
              "- 'with' - виконує блок коду над об'єктом, але не повертає результат. Використовується для тимчасового спрощення доступу до властивостей об'єкта.",
              "- 'use' - використовується для роботи з ресурсами, які потребують закриття після використання, наприклад, з файлами або сокетами. Він гарантує закриття ресурсу після виходу з блоку коду."
            ]
          },
          {
            "questionText": "Що станеться, якщо у класі перевизначити метод hashCode так: override fun hashCode(): Int = Random.nextInt()? А якщо так: override fun hashCode(): Int = 1?",
            "answerItems": [
              "Перевизначення методу 'hashCode' в такий спосіб може призвести до проблем і неправильної роботи механізмів, які використовують хеш-коди для порівняння об'єктів.",
              "Якщо 'hashCode' повертає випадкове значення 'Random.nextInt()', то хеш-код об'єкта буде змінюватися при кожному виклику, навіть якщо об'єкт не змінився. Це може призвести до неправильного розміщення об'єктів у хеш-таблицях, таких як HashMap, і втрати доступу до об'єктів.",
              "Якщо 'hashCode' завжди повертає фіксоване значення, наприклад, '1', то всі об'єкти будуть мати однаковий хеш-код, і це також може призвести до неправильної роботи механізмів, які використовують хеш-коди для порівняння об'єктів.",
              "Правильне перевизначення методу 'hashCode' має забезпечувати сталість хеш-коду для об'єкта, яка базується на його стані. Зазвичай це виконується за допомогою обчислення хеш-коду на основі певних властивостей об'єкта, які не змінюються під час його життєвого циклу."
            ]
          },
          {
            "questionText": "Розкажіть про Flow. У чому різниця між Hot і Cold Flow?",
            "answerItems": [
              "Flow - це асинхронний потік даних у Kotlin, який представляє собою послідовність значень, що можуть бути відправлені та оброблені асинхронно. Він дозволяє легко вирішувати проблеми, пов'язані з асинхронним програмуванням, та пропонує чистий та зрозумілий спосіб робити асинхронні операції.",
              "Різниця між Hot і Cold Flow полягає в тому, як вони ведуть себе при підписці на них:",
              "- Cold Flow - при кожній підписці на Cold Flow створюється новий незалежний потік даних, і всі підписники отримують однаковий набір даних з початку. Це означає, що дані не діляться між підписниками, і кожен отримує свою копію потоку даних.",
              "- Hot Flow - Hot Flow є спільним для всіх підписників, і він не починає відправляти дані, поки на нього не підпишуться. Якщо після цього на нього підпишуться більше підписників, то всі вони отримають ті ж самі дані з поточної позиції потоку. Тобто дані діляться між всіма підписниками, і вони отримують дані, які були відправлені після їхньої підписки."
            ]
          },
          {
            "questionText": "Що таке деструктуруюче оголошення? Що необхідно зробити, щоб мати можливість використовувати його для свого класу? Які проблеми можуть виникнути з таким оголошенням?",
            "answerItems": [
              "Деструктуруюче оголошення (Destructuring Declaration) - це механізм в Kotlin, який дозволяє розпаковувати об'єкти та витягувати їхні значення в окремі змінні. Це особливо корисно при роботі з кортежами, паралельними присвоєннями та іншими ситуаціями, де потрібно розпакувати об'єкти.",
              "Щоб мати можливість використовувати деструктуруюче оголошення для свого класу, потрібно визначити функцію 'componentN()' для класу, де 'N' - це порядковий номер поля, яке ви хочете розпакувати. Наприклад, якщо в класі є два поля 'name' і 'age', то можна визначити функції 'component1()' і 'component2()' для цього класу.",
              "Проблеми, які можуть виникнути з деструктуруючими оголошеннями, включають:",
              "- Неочевидність - в коді може бути важко зрозуміти, які саме значення розпаковуються, якщо назви компонентів не інтуітивні.",
              "- Конфлікти - якщо декілька полів класу мають однакові назви компонентів, то може виникнути конфлікт при спробі розпакувати об'єкт.",
              "- Перевизначення - якщо вже існують функції 'componentN()' для класу, то може бути важко додавати нові компоненти без змінення сигнатури функцій."
            ]
          },
          {
            "questionText": "Для чого використовувати data class? Чому не можна працювати зі звичайним класом?",
            "answerItems": [
              "Data class використовуються в Kotlin для представлення об'єктів, що містять дані (data objects). Вони автоматично генерують деякі стандартні методи, такі як 'equals()', 'hashCode()', 'toString()', 'componentN()', що спрощує роботу з об'єктами та робить код більш зрозумілим і безпечним.",
              "Відмінність між data class і звичайним класом полягає в тому, що для data class автоматично генеруються методи 'equals()', 'hashCode()', 'toString()', що дозволяє порівнювати об'єкти за їхнім вмістом, а не по ссилці. Це особливо корисно при роботі з колекціями та роботі зі зберіганням даних."
            ]
          },
          {
            "questionText": "Наведіть приклад делегатів у Kotlin?",
            "answerItems": [
              "У Kotlin можна використовувати делегати для розширення функціональності об'єктів. Наприклад, ви можете створити власний делегат, який додає певну логіку до геттера та сеттера властивості.",
              "Приклад:",
              "```kotlin",
              "class ExampleDelegate {",
              "  operator fun getValue(thisRef: Any?, property: KProperty<*>): String {",
              "    return \"Hello from delegate\"",
              "  }",
              "}",
              "",
              "class Example {",
              "  val message by ExampleDelegate()",
              "}",
              "",
              "fun main() {",
              "  val example = Example()",
              "  println(example.message) // Виведе 'Hello from delegate'",
              "}",
              "```"
            ]
          },
          {
            "questionText": "Як реалізувати кастомний делегат?",
            "answerItems": [
              "Для створення кастомного делегата в Kotlin потрібно створити клас, який реалізує два методи: 'getValue()' для геттера та 'setValue()' для сеттера. Метод 'getValue()' приймає два параметри: 'thisRef' (посилання на об'єкт, який використовує делегат) і 'property' (властивість, для якої викликано делегат).",
              "Приклад:",
              "```kotlin",
              "import kotlin.reflect.KProperty",
              "",
              "class CustomDelegate {",
              "  private var value: String = \"\"",
              "  operator fun getValue(thisRef: Any?, property: KProperty<*>): String {",
              "    return value",
              "  }",
              "  operator fun setValue(thisRef: Any?, property: KProperty<*>, newValue: String) {",
              "    value = \"Custom: $newValue\"",
              "  }",
              "}",
              "",
              "class Example {",
              "  var message by CustomDelegate()",
              "}",
              "",
              "fun main() {",
              "  val example = Example()",
              "  println(example.message) // Виведе пустий рядок",
              "  example.message = \"Hello\"",
              "  println(example.message) // Виведе 'Custom: Hello'",
              "}",
              "```"
            ]
          },
          {
            "questionText": "Поясніть, як працює suspen- функція? Що таке continuation?",
            "answerItems": [
              "Suspending function (suspen-функція) - це функція в Kotlin, яка може призупиняти виконання та відновлювати його пізніше, не блокуючи потік виконання. Вони використовуються в асинхронному програмуванні, особливо в контексті корутин (coroutines).",
              "Кожна suspen-функція отримує об'єкт Continuation як аргумент, який представляє точку виконання після відновлення функції. Функція може призупинити своє виконання, передаючи результат через Continuation, і потім пізніше відновити виконання з того місця, де вона була призупинена.",
              "Наприклад, використання корутин:",
              "```kotlin",
              "suspend fun fetchData() {",
              "  // Очікування даних",
              "}",
              "",
              "fun main() {",
              "  runBlocking {",
              "    // Створення корутини",
              "    val job = launch {",
              "      val data = fetchData() // Функція призупиняє виконання, але не блокує потік",
              "      println(data)",
              "    }",
              "    // Чекаємо завершення корутини",
              "    job.join()",
              "  }",
              "}",
              "```"
            ]
          },
          {
            "questionText": "Як обробляти помилки в Coroutines?",
            "answerItems": [
              "Обробка помилок в Coroutines зазвичай виконується за допомогою конструкції 'try/catch'. Відомий спосіб - це використання 'async/await' для оточення виконання коду, який може викинути виключення.",
              "Приклад:",
              "```kotlin",
              "import kotlinx.coroutines.*",
              "",
              "fun main() = runBlocking {",
              "    val job = GlobalScope.launch {",
              "        try {",
              "            // Операція, яка може викинути виключення",
              "        } catch (e: Exception) {",
              "            // Обробка виключення",
              "        }",
              "    }",
              "    job.join()",
              "}",
              "```",
              "Також можна використовувати 'CoroutineExceptionHandler' для глобального обробки помилок в корутині."
            ]
          },
          {
            "questionText": "Що таке SupervisorJob і коли застосовується?",
            "answerItems": [
              "SupervisorJob - це спеціальний тип корутинного Job, який використовується для створення корутин в рамках відокремленого супервайзера (supervisor). Він використовується для створення корутин, які мають окремого батька і не впливають на інші корутини в рамках супервайзера.",
              "SupervisorJob корисний в ситуаціях, коли важливо відокремити обробку помилок в одній корутині від інших. Якщо корутині з SuprvisorJob викинути виключення, це не призведе до скасування інших корутин в супервайзері.",
              "Приклад:",
              "```kotlin",
              "import kotlinx.coroutines.*",
              "",
              "fun main() = runBlocking {",
              "    val supervisor = SupervisorJob()",
              "    val scope = CoroutineScope(Dispatchers.Default + supervisor)",
              "",
              "    val job1 = scope.launch {",
              "        delay(100)",
              "        println(\"Job 1 completed\")",
              "    }",
              "",
              "    val job2 = scope.launch {",
              "        delay(50)",
              "        throw Exception(\"Job 2 failed\")",
              "    }",
              "",
              "    job1.join()",
              "    job2.join()",
              "}",
              "```"
            ]
          },
          {
            "questionText": "Як зупинити/скасувати Coroutines?",
            "answerItems": [
              "Скасування корутини виконується за допомогою методу 'cancel()' для об'єкта 'Job', пов'язаного з корутиною. Зауважте, що скасування корутини не гарантує його негайного завершення. Корутина може перевіряти 'isActive' та виходити, коли це можливо.",
              "Приклад:",
              "```kotlin",
              "import kotlinx.coroutines.*",
              "",
              "fun main() = runBlocking {",
              "    val job = launch {",
              "        repeat(10) {",
              "            println(\"Working...\")",
              "            delay(100)",
              "            if (!isActive) {",
              "                println(\"Cancelled\")",
              "                return@launch",
              "            }",
              "        }",
              "    }",
              "",
              "    delay(500)",
              "    job.cancel() // Скасувати корутину",
              "    job.join() // Чекаємо завершення корутини",
              "}",
              "```"
            ]
          }
        ]
      },
      {
        "topic": "RxJava",
        "questions": [
          {
            "questionText": "У чому різниця між flatMap(), concatMap(), switchMap()?",
            "answerItems": [
              "Всі ці оператори в RxJava використовуються для обробки і об'єднання потоків даних з багатьох вхідних потоків, але вони працюють по-різному:",
              "1. `flatMap()`: Вибирає один із вхідних елементів і генерує новий потік даних для кожного з цих елементів. Потім всі потоки об'єднуються в один вихідний потік. Порядок вихідних елементів може бути випадковим через асинхронну обробку.",
              "2. `concatMap()`: Схожий на `flatMap()`, але зберігає порядок вихідних елементів таким, яким вони прийшли в потік. Він чекає завершення обробки одного вхідного елемента, перш ніж перейти до наступного.",
              "3. `switchMap()`: Цей оператор завжди працює з останнім вхідним елементом і скасовує попередню обробку, якщо вона ще не завершилася. Тобто він вибирає найактуальніший потік даних та ігнорує попередні.",
              "Вибір між ними залежить від потреб конкретного випадку, де вони використовуються. `concatMap()` зазвичай використовується, коли потрібно зберегти порядок, `switchMap()` - коли останній вхідний елемент є актуальним, а `flatMap()` - коли порядок не має значення і обробка може бути асинхронною."
            ]
          },
          {
            "questionText": "Які Subjects ви знаєте в RxJava, чим відрізняються від Observable?",
            "answerItems": [
              "У RxJava існують різні типи Subjects, такі як BehaviorSubject, PublishSubject, ReplaySubject, AsyncSubject і т. д. Subjects є імплементаціями інтерфейсу 'Observer' та 'Observable' одночасно. Вони використовуються для створення та керування потоками даних, і вони можуть бути одночасно джерелом і споживачем даних.",
              "Основна відмінність між Subjects і Observable в тому, що Subjects можуть динамічно генерувати та надсилати нові елементи, в той час як Observable призначений для статичної обробки потоку даних. Subjects також зазвичай використовуються для спільної роботи між різними частинами програми, які мають доступ до них, для того щоб підписники могли підключитися до них пізніше і отримувати нові дані."
            ]
          },
          {
            "questionText": "Чим відрізняється Observable від Flowable?",
            "answerItems": [
              "Observable і Flowable є обидва частинами RxJava і використовуються для роботи з асинхронними потоками даних. Основна відмінність полягає в їх призначенні та властивостях:",
              "1. Розмір буфера: Основна відмінність полягає в тому, що Flowable розроблений для роботи з потоками даних, які можуть генерувати дані значно швидше, ніж споживачі можуть їх обробити. Тому Flowable має підтримку буферизації (backpressure) для контролю над занадто великими потоками даних. Observable не має цієї підтримки за замовчуванням.",
              "2. Підтримка backpressure: Flowable надає можливість обробки великих обсягів даних шляхом контролю над тимпом подачі даних з джерела до споживача, в той час як Observable не має вбудованої підтримки backpressure і може викликати проблеми, коли дані генеруються швидше, ніж вони можуть бути оброблені.",
              "Вибір між Observable і Flowable залежить від конкретної ситуації і вимог вашого додатка. Якщо ви не працюєте з великими потоками даних або не потребуєте контролю над backpressure, Observable може бути зручнішим варіантом. У протилежному випадку Flowable може бути кращим вибором для ефективної обробки потоків даних."
            ]
          },
          {
            "questionText": "Що таке backpressure? Які стратегії є для вирішення?",
            "answerItems": [
              "Backpressure - це ситуація, коли велика кількість даних генерується швидше, ніж вони можуть бути оброблені споживачем в асинхронному потоці даних. Це може призвести до переповнення пам'яті та падіння додатку.",
              "Для вирішення проблеми backpressure в RxJava існують різні стратегії:",
              "1. `BUFFER` (по замовчуванню): Всі елементи, які не можуть бути відразу оброблені, зберігаються в буфері. Ця стратегія може призвести до використання багато пам'яті.",
              "2. `DROP`: Нові елементи відкидаються, якщо буфер вже заповнений.",
              "3. `LATEST`: Споживач отримує тільки останній доступний елемент з буфера, і попередні елементи видаляються.",
              "4. `ERROR`: Генерується помилка `MissingBackpressureException`, якщо буфер переповнений. Це може бути використано для експліцитного виявлення проблеми backpressure.",
              "5. `DROP_OLDEST`: Відкидаються старі елементи в буфері, щоб звільнити місце для нових.",
              "Вибір стратегії залежить від конкретної ситуації та вимог вашого додатку. Іноді може знадобитися комбінування різних стратегій для досягнення бажаного результату."
            ]
          },
          {
            "questionText": "Що таке Single, Maybe, Completable?",
            "answerItems": [
              "Це спеціальні типи обсерверів в RxJava, які використовуються для представлення різних сценаріїв обробки даних:",
              "1. `Single`: Використовується для випадків, коли очікується один конкретний елемент або помилка. Наприклад, запит до сервера, який повертає один об'єкт.",
              "2. `Maybe`: Подібний до `Single`, але може не повертати жодного елемента, або повертати один елемент, або сигналізувати про помилку. Використовується для випадків, коли результат не завжди присутній.",
              "3. `Completable`: Використовується, коли очікується лише сигнал про завершення асинхронної операції, без повернення конкретних даних. Наприклад, виконання операції на сервері без повернення результату.",
              "Використання цих типів допомагає виразно виражати інтент та очікуваний результат операції."
            ]
          },
          {
            "questionText": "Які варіанти обробки помилок є, окрім onError?",
            "answerItems": [
              "В RxJava є кілька способів обробки помилок, окрім обробки в методі `onError`:",
              "1. `onErrorReturnItem`: Дозволяє вказати значення, яке буде вибране, якщо виникає помилка.",
              "2. `onErrorResumeNext`: Переключається на альтернативний Observable при виникненні помилки.",
              "3. `onErrorReturn`: Дозволяє повернути значення на основі помилки.",
              "4. `retry`: Повторює спроби після виникнення помилки до досягнення заданої кількості спроб або заданого умовного виразу.",
              "5. `retryWhen`: Дозволяє використовувати спеціальний Observable для управління логікою повторних спроб.",
              "6. `onExceptionResumeNext`: Схожий на `onErrorResumeNext`, але викликається при виникненні виключень (Exception), а не помилок (Error).",
              "Ці способи дозволяють більш гнучко обробляти помилки і приймати відповідні рішення в залежності від конкретної ситуації."
            ]
          }
        ]
      },
      {
        "topic": "Тестування",
        "questions": [
          {
            "questionText": "На які групи можна поділити тести (Unit (JUnit) і Instrumental або UI Tests (espresso))?",
            "answerItems": [
              "Тести в Android можна поділити на дві основні групи:",
              "1. Unit тести (JUnit): Ці тести перевіряють окремі частини коду, такі як методи або класи, в ізоляції від решти додатку. Вони дозволяють перевірити правильність роботи окремих функцій або компонентів без взаємодії з реальними залежностями.",
              "2. Instrumental або UI тести (espresso): Ці тести виконуються на реальному пристрої або емуляторі та перевіряють взаємодію між компонентами додатку та користувачем. Вони дозволяють перевірити, чи працює інтерфейс користувача коректно та чи відбуваються правильні дії при взаємодії з додатком."
            ]
          },
          {
            "questionText": "Чим відрізняються Unit і UI тести (контекст)?",
            "answerItems": [
              "Unit тести та UI тести відрізняються наступним чином:",
              "1. Контекст виконання:",
              "- Unit тести: Виконуються в ізольованому середовищі, де можна штучно створювати залежності та симулювати різні сценарії безпосередньої роботи методів або класів.",
              "- UI тести: Виконуються на реальних або емульованих пристроях, де взаємодія з додатком відбувається так, як це робить користувач. UI тести перевіряють, як додаток взаємодіє з реальними компонентами, такими як екран, клавіатура, сенсорний екран тощо.",
              "2. Мета:",
              "- Unit тести: Спрямовані на перевірку правильності роботи конкретного методу або класу, в ізоляції від інших компонентів.",
              "- UI тести: Спрямовані на перевірку функціональності додатку з точки зору користувача. Вони перевіряють, чи працює інтерфейс коректно та чи відбуваються правильні дії при взаємодії з додатком.",
              "3. Тривалість виконання:",
              "- Unit тести: Зазвичай виконуються швидше, оскільки вони не вимагають запуску додатку на пристрої або емуляторі.",
              "- UI тести: Можуть бути більш часомісткими, оскільки вони вимагають запуску та інтеракції з додатком на пристрої або емуляторі.",
              "Обидві групи тестів є важливими для забезпечення якості додатку, і їх вибір залежить від конкретних потреб і завдань тестування."
            ]
          },
          {
            "questionText": "Розкажіть, які бібліотеки використовували для mock?",
            "answerItems": [
              "Для створення моків (підроблених об'єктів) у тестуванні Android додатків часто використовують наступні бібліотеки:",
              "1. Mockito: Mockito є однією з найпопулярніших бібліотек для створення моків. Вона дозволяє легко створювати мок-об'єкти та визначати їх поведінку в тестах.",
              "2. PowerMock: PowerMock розширює можливості Mockito, дозволяючи мокати статичні методи, фінальні класи та інші складні сценарії.",
              "3. Robolectric: Robolectric - це бібліотека для тестування Android додатків, яка надає змогу виконувати тести на реальних об'єктах Android, а не на моках. Вона дозволяє імітувати середовище Android у тестах.",
              "4. Espresso: Espresso - це бібліотека для UI-тестів, яка дозволяє взаємодіяти з інтерфейсом користувача та перевіряти його стан. Ця бібліотека не використовує моків, оскільки вона спеціалізується на UI-тестуванні.",
              "Вибір бібліотеки для моків залежить від конкретних потреб та вимог вашого проекту. Кожна з цих бібліотек має свої особливості та переваги, і їх можна поєднувати в одному проекті залежно від потреб."
            ]
          },
          {
            "questionText": "Як тестувати DB?",
            "answerItems": [
              "Для тестування бази даних (DB) в Android, ви можете використовувати наступні підходи та інструменти:",
              "1. Інструментальні тести: Ви можете створювати інструментальні тести, які запускаються на пристрої або емуляторі та спілкуються з реальною базою даних вашого додатка. Використовуйте AndroidJUnit та Room для створення таких тестів.",
              "2. Мокування бази даних: Ви можете використовувати бібліотеки, які надають можливість створювати моки бази даних для тестування. Наприклад, для Room можна використовувати In-Memory базу даних для тестів, яка не зберігає дані між запусками.",
              "3. Espresso та UI тести: Для перевірки, чи правильно відображаються дані з бази даних у вашому інтерфейсі користувача, ви можете використовувати Espresso для UI-тестів, які перевіряють відображення та взаємодію з елементами інтерфейсу.",
              "4. Інтеграційні тести: Створюйте інтеграційні тести, які перевіряють взаємодію різних компонентів вашого додатка з базою даних.",
              "5. Використання бібліотек для тестування: Ви можете використовувати сторонні бібліотеки, такі як Robolectric або Android Test Orchestrator, для полегшення тестування бази даних у вашому додатку.",
              "Важливо розробляти тести для різних сценаріїв, включаючи додавання, оновлення, видалення та запити до бази даних, щоб переконатися, що вона працює коректно та надійно."
            ]
          },
          {
            "questionText": "Як замокати network layer в інструментальних тестах?",
            "answerItems": [
              "Для мокування мережевого шару (network layer) в інструментальних тестах Android додатка, ви можете використовувати наступні підходи та інструменти:",
              "1. Retrofit Mocking: Якщо ви використовуєте бібліотеку Retrofit для взаємодії з API, ви можете використовувати бібліотеки, такі як OkHttp Interceptors або Retrofit Mock для мокування запитів та відповідей в інструментальних тестах.",
              "2. MockWebServer: MockWebServer - це бібліотека, яка дозволяє створювати тестовий HTTP-сервер, який обробляє запити та повертає моковані відповіді. Ви можете використовувати її для мокування мережевих запитів у ваших тестах.",
              "3. Dependency Injection: Використання паттерну Dependency Injection (DI) дозволяє вставляти моковані об'єкти мережевого шару в ваші класи для взаємодії з мережею. Для DI ви можете використовувати Dagger, Hilt або інші DI-фреймворки.",
              "4. Використання сторонніх бібліотек: Деякі сторонні бібліотеки, такі як MockK або Mockito, надають можливість мокувати об'єкти та методи для тестування.",
              "Важливо пам'ятати, що мокування мережевого шару допомагає вам тестувати ваш додаток у віртуальному середовищі без реальних мережевих взаємодій, що робить тести більш передбачуваними та швидкими."
            ]
          }
        ]
      },
      {
        "topic": "DI фреймворки",
        "questions": [
          {
            "questionText": "Розкажіть, з якими DI-фреймворками працювали.",
            "answerItems": [
              "Ми працювали з декількома DI-фреймворками для Android розробки, включаючи наступні:",
              "1. Dagger 2: Dagger 2 - це популярний DI-фреймворк для Android, який надає засоби для внедрення залежностей в Android додатках. Він використовує анотації та генерацію коду для створення графа залежностей.",
              "2. Hilt: Hilt - це спеціалізований DI-фреймворк, розроблений Google для Android. Він ґрунтується на Dagger 2 та надає спрощений та зрозумілий спосіб використання DI в Android додатках.",
              "3. Koin: Koin - це легкий DI-фреймворк для Kotlin, який не вимагає генерації коду та використовує DSL для конфігурації залежностей.",
              "4. Toothpick: Toothpick - це ще один DI-фреймворк для Android, який пропонує різні стратегії внедрення залежностей, включаючи конструктори, методи та анотації.",
              "Кожен з цих DI-фреймворків має свої переваги та особливості, і вибір залежить від конкретних потреб вашого проекту та ваших вподобань у роботі з DI."
            ]
          },
          {
            "questionText": "Розкажіть про Dagger Hilt.",
            "answerItems": [
              "Dagger Hilt - це DI-фреймворк, розроблений командою Google спеціально для Android додатків. Він побудований на основі Dagger 2 і надає спрощений та зрозумілий спосіб використання DI в Android проектах.",
              "Основні особливості Dagger Hilt:",
              "- Забезпечує автоматичну генерацію коду для створення графа залежностей, що робить його дуже зручним для використання.",
              "- Надає анотації для позначення класів, які потрібно внедрювати залежності, такі як @HiltViewModel, @HiltAndroidApp тощо.",
              "- Підтримує Android-особливості, такі як внедрення залежностей в Application, Activity, Fragment, ViewModel тощо.",
              "- Пропонує зручний спосіб конфігурування та налаштування DI в додатку.",
              "Dagger Hilt спрощує процес внедрення залежностей та допомагає підтримувати чистий та читабельний код в Android додатках. Він є одним з рекомендованих варіантів для DI в Android розробці від Google."
            ]
          }
        ]
      }
    ]
  },
  {
    "levelTitle": "Senior",
    "questions": [
      {
        "topic": "Базові питання",
        "questions": [
          {
            "questionText": "Розкажіть про функції вищого порядку. Коли вони потрібні?",
            "answerItems": [
              "Функції вищого порядку - це функції, які приймають інші функції як аргументи або повертають їх як результат. Вони є важливою частиною функціонального програмування і дозволяють писати більш загальні та абстрактні функції.",
              "Функції вищого порядку потрібні, коли вам потрібно передати логіку виконання або обробки даних в іншу функцію. Вони роблять код більш зрозумілим, перевикористовуваним та менш вразливим до змін.",
              "Приклади ситуацій, коли функції вищого порядку потрібні:",
              "- Сортування: Ви можете передати функцію порівняння як аргумент до функції сортування.",
              "- Фільтрація: Ви можете передати умову фільтрації як аргумент до функції фільтрації.",
              "- Обробка подій: Ви можете передати функцію обробки подій для обробки реакції на події користувача.",
              "- Виконання коду в майбутньому: Ви можете передати функцію, яка буде виконана пізніше.",
              "Функції вищого порядку допомагають зменшити дублювання коду, покращують читабельність та об'єднують логіку в більш абстрактних та потужних способах."
            ]
          },
          {
            "questionText": "Опишіть, як відбувається процес деплою Android-програми.",
            "answerItems": [
              "Процес деплою Android-програми включає наступні кроки:",
              "1. Компіляція: Розробник пише код програми на мові програмування Java або Kotlin. Після цього код компілюється в байт-код Java, який може бути виконаний на віртуальній машині Java (JVM).",
              "2. Упакування: Упакування програми в архівний файл з розширенням .apk (Android Package). Цей файл містить всі ресурси, код та інші компоненти програми.",
              "3. Підпис: Після упаковки програми, розробник повинен підписати .apk файл, щоб забезпечити цілісність та автентичність програми. Це робиться за допомогою ключа, який виданий розробнику.",
              "4. Розповсюдження: Після підпису програма готова до розповсюдження. Ви можете розповсюджувати програму через Google Play Store, сторонні магазини, електронну пошту або інші канали.",
              "5. Встановлення: Користувачі завантажують .apk файл на свої Android-пристрої та встановлюють програму на них. Процес встановлення розпаковує .apk файл та розміщує компоненти програми на пристрої.",
              "6. Виконання: Після встановлення програма готова до виконання на Android-пристрої. Користувач може запускати програму та використовувати її функціональність.",
              "Важливо пам'ятати, що під час деплою програми на Google Play Store вимагається додаткова процедура, яка включає модерацію та публікацію програми."
            ]
          },
          {
            "questionText": "Розкажіть про багатомодульну архітектуру. Для чого використовують і коли її немає сенсу використовувати?",
            "answerItems": [
              "Багатомодульна архітектура (або modular architecture) - це підхід до розробки програмного забезпечення, при якому програма розділена на окремі модулі або компоненти, які можуть бути розроблені, тестовані та втілені незалежно один від одного.",
              "Основні переваги багатомодульної архітектури:",
              "- Розділення відповідальностей: Кожен модуль відповідає за певний функціонал або компонент програми, що полегшує розробку та тестування.",
              "- Перевикористовування коду: Модулі можуть бути використані в інших програмах або проектах, що зменшує дублювання коду.",
              "- Швидкість розробки: Розробники можуть працювати над різними модулями паралельно, що прискорює розробку.",
              "- Забезпечення стабільності: Зміни в одному модулі не впливають на інші модулі, що допомагає зберігати стабільність програми.",
              "Зазвичай багатомодульна архітектура використовується в середніх і великих проектах, де код досить об'ємний і складний. Для маленьких простих програм цей підхід може бути зайвим та ускладнювати розробку."
            ]
          }
        ]
      },
      {
        "topic": "Архітектура",
        "questions": [
          {
            "questionText": "Яким чином організувати CI/CD для Android-проєктів?",
            "answerItems": [
              "Організація Continuous Integration (CI) та Continuous Deployment (CD) для Android-проєктів є важливою частиною розробки програмного забезпечення. Основні кроки для налагодження CI/CD для Android-проєктів включають наступне:",
              "1. Використання системи контролю версій (VCS): Розробники повинні використовувати VCS, таку як Git, для зберігання та керування вихідним кодом проєкту.",
              "2. Автоматизований збір інтеграції (CI): Встановіть систему CI, таку як Jenkins, Travis CI, CircleCI або GitLab CI/CD, для автоматичної збірки, тестування та перевірки коду при кожному коміті в репозиторій VCS.",
              "3. Автоматизована поставка (CD): Налаштуйте CD для автоматичного розгортання програми на тестових, стейджингових та продуктових серверах після успішного завершення CI-процесу.",
              "4. Автоматизовані тести: Створіть набір автоматизованих тестів, включаючи одиниць та інтеграційні тести, які виконуються під час CI/CD-процесу.",
              "5. Контроль версій APK: Використовуйте інструменти для керування версіями APK, такі як Gradle, для забезпечення правильної версії програми в репозиторії та її розповсюдження.",
              "6. Моніторинг і логування: Включіть системи моніторингу та логування для відстеження стану програми в реальному часі.",
              "7. Ручне тестування та QA: Попередній QA-перевірки перед релізом на продуктовий сервер залишаються важливим етапом в CI/CD-процесі.",
              "8. Виправлення помилок та покращення: Використовуйте зворотний зв'язок з розробниками та QA для виправлення помилок та покращення програми.",
              "CI/CD допомагає автоматизувати процес розробки та розгортання, забезпечуючи швидкіше виправлення помилок та швидше внесення змін у програму."
            ]
          },
          {
            "questionText": "Відмінності архітектурних підходів в Android. Які та коли краще використовувати?",
            "answerItems": [
              "У розробці Android-програм використовуються різні архітектурні підходи, такі як MVC (Model-View-Controller), MVP (Model-View-Presenter), MVVM (Model-View-ViewModel) та Clean Architecture. Кожен підхід має свої відмінності та властивості:",
              "1. **MVC (Model-View-Controller)**:",
              "   - **Model**: Модель представляє дані та бізнес-логіку.",
              "   - **View**: Представлення відображає дані користувачу.",
              "   - **Controller**: Контролер обробляє взаємодію користувача та викликає методи моделі для оновлення даних.",
              "   - **Коли використовувати**: MVC використовується в простих програмах, де бізнес-логіка невелика та нескладна.",
              "2. **MVP (Model-View-Presenter)**:",
              "   - **Model**: Модель відповідає за дані і бізнес-логіку.",
              "   - **View**: Представлення відображає дані та обробляє події від користувача.",
              "   - **Presenter**: Презентер взаємодіє з моделлю та представленням, обробляє події від користувача та оновлює відображення.",
              "   - **Коли використовувати**: MVP рекомендується для програм, де потрібно окремо відокремити логіку представлення та бізнес-логіку.",
              "3. **MVVM (Model-View-ViewModel)**:",
              "   - **Model**: Модель представляє дані та бізнес-логіку.",
              "   - **View**: Представлення відображає дані та слухає зміни в ViewModel.",
              "   - **ViewModel**: ViewModel містить логіку для відображення та взаємодії з моделлю, але не пов'язана з конкретним представленням.",
              "   - **Коли використовувати**: MVVM є популярним підходом, рекомендується для програм з великою кількістю UI-компонентів та даних.",
              "4. **Clean Architecture**:",
              "   - **Суть**: Clean Architecture визначає окремі шари програми для представлення, бізнес-логіки та джерел даних. Кожен шар має власну відповідальність та міжшарову ізоляцію.",
              "   - **Коли використовувати**: Clean Architecture рекомендується для складних проектів, де важлива масштабованість, тестування та підтримка довготривалих проектів.",
              "Вибір архітектурного підходу залежить від розміру, складності та потреб програми."
            ]
          },
          {
            "questionText": "Як ви розумієте Clean Architecture?",
            "answerItems": [
              "Clean Architecture (Чиста Архітектура) - це підхід до розробки програмного забезпечення, який розділяє додаток на окремі шари з чіткою відповідальністю та ізоляцією між ними. Ця архітектура розроблена Робертом Мартіном (Robert C. Martin) та визначає загальну структуру програми так, щоб бізнес-логіка була відокремлена від деталей реалізації та залежностей.",
              "Основні шари Clean Architecture включають:",
              "- **Представлення (Presentation Layer)**: Цей шар відповідає за відображення даних користувачу та обробку взаємодії з ним. Він містить активності, фрагменти, ViewModel (якщо використовується MVVM), а також інші UI-компоненти.",
              "- **Бізнес-логіка (Domain Layer)**: Шар бізнес-логіки містить основну функціональність додатку, включаючи бізнес-правила та обробку даних. Він незалежний від конкретних інструментів та технологій.",
              "- **Джерела даних (Data Layer)**: Шар джерел даних відповідає за доступ до зовнішніх джерел даних, таких як бази даних, API, файлова система тощо. Він ізолює бізнес-логіку від деталей роботи з даними.",
              "Основні принципи Clean Architecture включають в себе інверсію залежностей (Dependency Inversion Principle), що означає, що залежності повинні спрямовуватися від абстракцій до конкретних реалізацій, а також принцип відокремлення інтерфейсів (Interface Segregation Principle) та принцип єдиного обов'язку (Single Responsibility Principle).",
              "Clean Architecture сприяє підтримці та розширенню коду, полегшує тестування та підтримку, а також допомагає уникнути проблем залежностей."
            ]
          },
          {
            "questionText": "Опишіть основні відмінності між MVC/MVP і MVVM. Яким чином MVVM став одним з рекомендованих патернів?",
            "answerItems": [
              "MVC (Model-View-Controller), MVP (Model-View-Presenter) та MVVM (Model-View-ViewModel) - це архітектурні патерни, які використовуються для організації коду у програмах з інтерфейсом користувача. Основні відмінності між ними включають наступне:",
              "1. **MVC (Model-View-Controller)**:",
              "   - **Model**: Модель представляє дані та бізнес-логіку.",
              "   - **View**: Представлення відображає дані користувачу.",
              "   - **Controller**: Контролер обробляє взаємодію користувача та викликає методи моделі для оновлення даних.",
              "2. **MVP (Model-View-Presenter)**:",
              "   - **Model**: Модель відповідає за дані і бізнес-логіку.",
              "   - **View**: Представлення відображає дані та обробляє події від користувача.",
              "   - **Presenter**: Презентер взаємодіє з моделлю та представленням, обробляє події від користувача та оновлює відображення.",
              "3. **MVVM (Model-View-ViewModel)**:",
              "   - **Model**: Модель представляє дані та бізнес-логіку.",
              "   - **View**: Представлення відображає дані та слухає зміни в ViewModel.",
              "   - **ViewModel**: ViewModel містить логіку для відображення та взаємодії з моделлю, але не пов'язана з конкретним представленням.",
              "Головна відмінність MVVM полягає в наявності ViewModel, яка розділяє бізнес-логіку від представлення. ViewModel зазвичай містить логіку для завантаження та оновлення даних, а також управління станом UI. MVVM спрощує тестування та підтримку, а також дозволяє використовувати технології, які полегшують реактивне програмування.",
              "MVVM став рекомендованим патерном в розробці Android-програм завдяки бібліотеці Android Jetpack, яка включає в себе компоненти, призначені для реалізації MVVM-архітектури. Ці компоненти, такі як LiveData та ViewModel, роблять розробку програм більш зручною та ефективною."
            ]
          }
        ]
      },
      {
        "topic": "Багатопотоковість",
        "questions": [
          {
            "questionText": "Які ще знаєте механізми синхронізації даних, окрім synchronized?",
            "answerItems": [
              "Поза ключовим словом `synchronized`, яке використовується для синхронізації доступу до об'єктів в Java, існують інші механізми синхронізації даних, такі як:",
              "1. **ReentrantLock**: Це клас, який надає більше гнучкості в порівнянні з `synchronized`. Ви можете створити і керувати багатьма блокуваннями, встановити таймаути, визначити справедливе (fair) або несправедливе (unfair) блокування тощо.",
              "2. **Semaphore**: Semaphore - це лічильник, який обмежує кількість потоків, які можуть отримати доступ до певного ресурсу одночасно. Він часто використовується для обмеження паралельного доступу до ресурсів.",
              "3. **CountDownLatch**: CountDownLatch дозволяє одному або декільком потокам чекати, доки інші потоки завершать свою роботу, перед тим як продовжити виконання.",
              "4. **CyclicBarrier**: CyclicBarrier - це бар'єр, який дозволяє групі потоків чекати одне на одного, перш ніж продовжити виконання. Це корисно для синхронізації декількох потоків, які мають виконати певну операцію паралельно, а потім чекати одне на одного.",
              "5. **Phaser**: Phaser - це сучасний механізм синхронізації, який надає можливість керувати фазами виконання потоків. Він дозволяє групі потоків синхронізуватися на певних точках виконання.",
              "Ці механізми синхронізації даних дозволяють більш гнучко та точно керувати доступом до ресурсів та синхронізацією потоків в порівнянні з `synchronized`."
            ]
          },
          {
            "questionText": "Що таке перемикання контексту (context-switching), коли йдеться про багатопотоковість?",
            "answerItems": [
              "Перемикання контексту (context-switching) - це процес, коли операційна система переходить від виконання одного потоку до виконання іншого потоку. Кожна операційна система має свій власний планувальник, який визначає, які потоки отримують можливість виконуватися в конкретний момент часу.",
              "Під час перемикання контексту, поточний стан виконання потоку (включаючи значення регістрів та стек) зберігається, і потім відновлюється для іншого потоку. Це відбувається для забезпечення враження, ніби потоки виконуються паралельно, хоча фактично вони просто швидко перемикаються.",
              "Перемикання контексту може бути витратним процесом, оскільки воно вимагає збереження та відновлення стану потоків, і це може вплинути на продуктивність програми. Отже, оптимізація і ефективне використання потоків та ресурсів є важливою задачею при розробці багатопотокових програм."
            ]
          },
          {
            "questionText": "Що ми розуміємо, коли кажемо про «чесне» блокування (fair lock)?",
            "answerItems": [
              "Коли ми говоримо про «чесне» блокування (fair lock), ми маємо на увазі механізм синхронізації, де потоки отримують доступ до ресурсу в тому порядку, в якому вони запитали про доступ. Тобто перший потік, який запитав доступ, отримує його першим, другий - другим і так далі.",
              "«Чесне» блокування важливе в ситуаціях, де потрібно запобігти або мінімізувати простійну або неправильну конкуренцію між потоками за обмежені ресурси. Воно забезпечує справедливий доступ до ресурсів для всіх потоків, які їх запитують.",
              "Зазвичай, «чесне» блокування можна досягти за допомогою механізмів, таких як семафори (Semaphore) або блокування ReentrantLock з параметром справедливого блокування.",
              "Проте варто пам'ятати, що «чесне» блокування може призвести до деякого додаткового навантаження на систему через необхідність управління чергами запитів на доступ до ресурсу. У деяких випадках, коли точний порядок важливий, «чесне» блокування може бути відмінним вибором."
            ]
          }
        ]
      },
      {
        "topic": "Java Core",
        "questions": [
          {
            "questionText": "Якби довелося імплементувати імутабельний клас на Java, як ви це зробили?",
            "answerItems": [
              "Для створення імутабельного (immutable) класу на Java слід виконати наступні кроки:",
              "1. Позначити клас ключовим словом `final`, щоб заборонити його підкласування.",
              "2. Полегшити створення об'єктів класу, використовуючи конструктор для ініціалізації всіх полів класу.",
              "3. Зробити всі поля класу приватними та оголосити їх як `final`, щоб заборонити зміну їх значень після створення об'єкта.",
              "4. Не надавати методив для зміни стану класу. Всі методи класу повинні бути безпечніми для зчитування та повертати нові об'єкти, якщо потрібно зробити зміни.",
              "5. Правильно перевизначити методи `equals()`, `hashCode()`, і можливо `toString()`, щоб вони відповідали новому визначенню рівності об'єктів на основі їхнього стану.",
              "6. Впевнитися, що клас не містить змінюваних об'єктів в своєму стані. Якщо клас має посилання на інші об'єкти, то ці об'єкти також повинні бути імутабельними або дубльовано захищені копією.",
              "Приклад імутабельного класу може виглядати так:",
              "```java",
              "public final class ImmutableClass {",
              "    private final int intValue;",
              "    private final String stringValue;",
              "",
              "    public ImmutableClass(int intValue, String stringValue) {",
              "        this.intValue = intValue;",
              "        this.stringValue = stringValue;",
              "    }",
              "",
              "    public int getIntValue() {",
              "        return intValue;",
              "    }",
              "",
              "    public String getStringValue() {",
              "        return stringValue;",
              "    }",
              "}",
              "```",
              "Цей клас неможливо змінити після створення об'єкта, і він гарантує незмінність даних."
            ]
          },
          {
            "questionText": "Що таке Java Memory Model?",
            "answerItems": [
              "Java Memory Model (JMM) - це специфікація, яка визначає правила доступу до пам'яті в багатопотокових програмах на мові програмування Java. Вона визначає, як потоки взаємодіють з пам'яттю та як змінні можуть бути видимі між потоками.",
              "Основні принципи Java Memory Model включають в себе:",
              "- Операції запису та читання взаємодіють з пам'яттю та кешем процесора відповідним чином.",
              "- Змінні, які не синхронізовані, можуть бути видимі в різних порядках для різних потоків (проблема видимості).",
              "- Використання ключових слів `volatile`, `synchronized`, `final` та інших механізмів синхронізації дозволяє контролювати взаємодію потоків та забезпечити правильність багатопотокової роботи.",
              "- Всі потоки бачать зміну значення змінних, коли вони виконують синхронізаційну дію (наприклад, блок `synchronized`).",
              "Java Memory Model гарантує відносну стабільність порядку операцій читання та запису між потоками. Вона забезпечує можливість робити програми багатопотоковими та зберігає консистентність даних при взаємодії потоків з пам'яттю."
            ]
          },
          {
            "questionText": "Порівняйте принципи композиції та наслідування (Composition vs Inheritance).",
            "answerItems": [
              "Принципи композиції та наслідування - це два різні підходи до створення класів та відносин між ними. Ось їх порівняння:",
              "1. **Наслідування (Inheritance)**:",
              "   - Відношення \"є частиною\" (is-a): Клас-спадкоємець є підтипом класу-батька.",
              "   - Спадкування поліморфізму: Клас-спадкоємець може перевизначити (override) методи класу-батька.",
              "   - Переваги: Перевикористання коду, загальні властивості та методи класу-батька успадковуються, що полегшує розробку.",
              "   - Недоліки: Заплутаність (brittleness) та порушення інкапсуляції, може призвести до проблем з підтримкою та розширенням, змушує використовувати інтерфейси для більшої гнучкості.",
              "2. **Композиція (Composition)**:",
              "   - Відношення \"має\" (has-a): Об'єкт класу містить або використовує інший об'єкт класу.",
              "   - Вкладений об'єкт не є підтипом зовнішнього класу, але він може бути доступним через методи зовнішнього класу.",
              "   - Переваги: Зменшення залежності між класами, більша інкапсуляція, більша гнучкість та можливість змінювати компоненти об'єкта незалежно.",
              "   - Недоліки: Деякий додатковий код для створення та взаємодії з вкладеними об'єктами.",
              "Обираючи між композицією та наслідуванням, варто враховувати конкретні вимоги проекту та структуру даних. У багатьох випадках, використання обох підходів в комбінації може бути найкращим рішенням."
            ]
          }
        ]
      },
      {
        "topic": "Android SDK",
        "questions": [
          {
            "questionText": "ViewModel зберігає свій стан під час повороту екрана? Як це можливо? Чи можете запропонувати, як зробити такий механізм?",
            "answerItems": [
              "Так, ViewModel призначений для збереження даних та стану під час повороту екрана та інших конфігураційних змін. Це можливо завдяки тому, що ViewModel зберігається на протязі життєвого циклу активності або фрагмента і автоматично відновлюється при необхідності.",
              "ViewModel зазвичай використовується разом з бібліотекою Android Architecture Components, зокрема з ViewModel і LiveData. Щоб забезпечити збереження стану ViewModel під час повороту екрана, можна виконати наступні кроки:",
              "1. Створіть підклас ViewModel та визначте в ньому поля, які потрібно зберігати.",
              "2. Відразу ж відразу створіть об'єкт ViewModel за допомогою ViewModelProvider у вашій активності або фрагменті.",
              "3. Використовуйте цей об'єкт ViewModel для отримання та збереження даних, необхідних для вашого інтерфейсу користувача.",
              "4. LiveData може використовуватися для надання даних інтерфейсу користувача, які автоматично оновлюються при зміні даних в ViewModel.",
              "При повороті екрана або зміні конфігурації активності, об'єкт ViewModel залишається незмінним і продовжує зберігати свій стан. Це дозволяє уникнути непотрібних витрат ресурсів на збереження стану вручну та полегшує розробку додатків на Android."
            ]
          },
          {
            "questionText": "Android Architecture Components. Що з цього доводилося застосовувати на практиці? Які задачі вирішували?",
            "answerItems": [
              "Android Architecture Components - це набір бібліотек від Google, призначених для полегшення розробки Android-додатків та забезпечення кращої архітектури додатків. Деякі з компонентів, які доводилося застосовувати на практиці, включають:",
              "1. **ViewModel**: Використовується для збереження та управління даними, пов'язаними з інтерфейсом користувача, та для забезпечення збереження стану під час повороту екрана.",
              "2. **LiveData**: Використовується для надання даних інтерфейсу користувача, які автоматично оновлюються при зміні даних в ViewModel.",
              "3. **Room**: Передбачає можливість роботи з базами даних SQLite на Android з використанням вищого рівня абстракції та можливість використання анотацій для визначення схеми даних.",
              "4. **Navigation**: Використовується для управління навігацією між екранами і фрагментами додатку.",
              "Ці компоненти допомагають розробникам створювати додатки, які краще структуровані, масштабовані та підтримувані. Вони спрощують вирішення проблем, пов'язаних з збереженням стану, управлінням даними та навігацією в додатках."
            ]
          },
          {
            "questionText": "Чи доводилося досліджувати «витоки» пам’яті? Які інструменти застосовували для цього?",
            "answerItems": [
              "Так, дослідження «витоків» пам'яті (memory leaks) є важливою частиною розробки Android-додатків, оскільки витоки пам'яті можуть призвести до великих проблем з продуктивністю та надійністю додатка. Для виявлення та вирішення витоків пам'яті можна використовувати наступні інструменти:",
              "1. **Android Profiler**: Інструмент вбудований в Android Studio, який дозволяє аналізувати використання пам'яті додатком в реальному часі. Він допомагає виявляти великі об'єкти, які можуть бути потенційними джерелами витоку пам'яті.",
              "2. **LeakCanary**: Це сторонній інструмент, який допомагає автоматично виявляти та надсилати повідомлення про витоки пам'яті. Він шукає об'єкти, які більше не можна досягти, але не були коректно видалені.",
              "3. **MAT (Memory Analyzer Tool)**: Цей інструмент від Eclipse MAT дозволяє аналізувати дампи пам'яті для знаходження витоків пам'яті та великих об'єктів.",
              "4. **StrictMode**: Інструмент, який можна включити в режимі розробки, і він допомагає виявляти деякі види витоків пам'яті, наприклад, недотримання правил мережевого виклику на основному потоці.",
              "Для дослідження витоків пам'яті важливо вести моніторинг та профілювання додатка, виявляти проблемні частини коду та здійснювати виправлення для забезпечення коректного вивільнення непотрібної пам'яті."
            ]
          },
          {
            "questionText": "Якби було завдання написати застосунок для інтернет-магазину з нуля, які технології/підходи обрали б?",
            "answerItems": [
              "Створення інтернет-магазину для Android - це завдання, яке вимагає розгляду багатьох аспектів, включаючи як бізнес-логіку, так і технічну реалізацію. Ось деякі з технологій та підходів, які можна було б використовувати при створенні такого застосунку:",
              "1. **Java або Kotlin**: Вибір мови програмування для Android залишається на ваш розсуд, але Kotlin стає все більш популярною і рекомендованою мовою для розробки Android-додатків.",
              "2. **Android Architecture Components**: Вони допоможуть вам побудувати добре структурований і масштабований додаток. ViewModel, LiveData, Room (для роботи з базами даних) та Navigation виявляться корисними.",
              "3. **Реактивне програмування**: Використання бібліотек, таких як RxJava або Kotlin Flow, для управління асинхронними операціями та обробки подій.",
              "4. **REST або GraphQL**: Вибір протоколу для взаємодії з сервером. REST є популярним варіантом, але GraphQL надає більшу гнучкість.",
              "5. **Firebase або інша хмарна платформа**: Використання хмарних послуг для автентифікації користувачів, зберігання даних, повідомлень тощо.",
              "6. **Матеріальний дизайн**: Використання Material Design для створення зручного та красивого інтерфейсу.",
              "7. **Платіжні системи**: Інтеграція з платіжними системами, такими як Google Pay або Apple Pay, для зручних платежів.",
              "8. **Аналітика та моніторинг**: Використання інструментів аналітики, таких як Google Analytics або Firebase Analytics, для збору даних про користувачів та їх поведінку.",
              "9. **Тестування**: Розробка та використання юніт-тестів, інтеграційних тестів та UI-тестів для забезпечення якості коду та додатку вцілому.",
              "10. **Забезпечення безпеки**: Захист даних користувачів, включаючи використання HTTPS, обробку вразливостей та автентифікацію користувачів.",
              "Це лише загальний набір технологій та підходів, які можна використовувати. Вибір конкретних інструментів та технологій буде залежати від конкретних вимог та обмежень вашого проекту."
            ]
          },
          {
            "questionText": "Наведіть приклад застосування GoF-патернів в Android SDK.",
            "answerItems": [
              "У Android розробці, так само як і в інших областях програмування, GoF-патерни можуть бути корисними для покращення структури коду та рішення специфічних задач. Ось кілька прикладів:",
              "1. **Патерн Одинак (Singleton)**: Використовується для забезпечення, що у вашому додатку існує лише один екземпляр певного класу. Наприклад, можна використовувати цей патерн для створення єдиного об'єкта для керування мережевим підключенням або для доступу до бази даних.",
              "2. **Фабричний метод (Factory Method)**: Допомагає створювати об'єкти без вказання конкретного класу. В Android, ви можете використовувати фабричні методи для створення фрагментів або подібних компонентів, особливо в ситуаціях, коли потрібно змінити реалізацію в майбутньому.",
              "3. **Оголошення (Observer)**: Використовується для реалізації патерну Cпостерігача, де один об'єкт слідкує та реагує на зміни в інших об'єктах. В Android, цей патерн може бути корисним для реалізації подій та оновлень інтерфейсу користувача.",
              "4. **Ланцюг відповідальності (Chain of Responsibility)**: Використовується для передачі запиту послідовно від одного об'єкта до іншого, поки один з об'єктів не обробить запит. В Android, цей патерн може бути використаний для обробки подій та запитів в активностях або фрагментах.",
              "Важливо відзначити, що використання GoF-патернів повинно бути обгрунтованим і підходящим для конкретної задачі. Зловживанням патернами може призвести до збільшення складності коду, тому їх слід застосовувати розумно та враховуючи конкретні потреби проекту."
            ]
          }
        ]
      },
      {
        "topic": "Kotlin",
        "questions": [
          {
            "questionText": "Опишіть взаємодію коду Kotlin та Java?",
            "answerItems": [
              "Kotlin та Java можуть співіснувати в одному проекті і взаємодіяти між собою без проблем, оскільки Kotlin розроблений так, щоб бути 100% сумісним з Java. Ось деякі аспекти взаємодії між ними:",
              "1. **Компіляція**: Код Kotlin компілюється в байт-код JVM, тому його можна використовувати в тому ж проекті, де вже є Java-код. Немає необхідності перекомпілювати всю програму.",
              "2. **Використання Java бібліотек**: Kotlin може легко використовувати бібліотеки, написані на Java, і навпаки. Котлин підтримує аннотації та функціональні інтерфейси з Java.",
              "3. **Nullable типи**: Kotlin має покращену підтримку Nullable типів, тобто він розрізняє null та non-null значення. Це допомагає уникнути NullPointerException. Java-код може викликати Kotlin-функції, враховуючи цю особливість.",
              "4. **Розширення функціональності Java-класів**: У Kotlin можна створювати розширення для існуючих Java-класів без модифікації їхнього вихідного коду.",
              "5. **Null Safety**: Kotlin надає покращену безпеку щодо роботи з null-значеннями, що допомагає уникнути багатьох типових помилок.",
              "6. **Лямбда-вирази**: Kotlin має більш зручний синтаксис для створення лямбда-виразів, але можна використовувати інтерфейси з Java для функціонального програмування.",
              "Взагалі, Kotlin спрощує розробку, покращує безпеку та відкриває нові можливості для розробників, які працюють зі старим Java-кодом або починають нові проекти."
            ]
          },
          {
            "questionText": "Що змінилося в обробці помилок у Kotlin, коли порівняти з Java?",
            "answerItems": [
              "У Kotlin відбулися деякі зміни у відношенні до обробки помилок порівняно з Java:",
              "1. **Винятки (Exceptions)**: У Kotlin використовується конструкція `try`-`catch`, але вона є менш обов'язковою. Kotlin надає можливість робити перевірку на винятки за допомогою типів (checked exceptions), але це не є обов'язковим. Ви можете використовувати `throw` для генерації винятків, але це рідше використовується.",
              "2. **Nullable типи**: Kotlin має Nullable типи, які допомагають уникнути NullPointerException. Це покращує безпеку та уникнення неконтрольованих винятків.",
              "3. **Конструкція `try`-`catch` як вирази**: У Kotlin конструкція `try`-`catch` може бути виразом, тобто ви можете отримувати значення з `try`-блоку, або з `catch`-блоку, залежно від того, де сталася помилка. Це спрощує обробку помилок та дозволяє більш елегантний код.",
              "4. **Функціональність для обробки null**: Kotlin надає ряд функцій для безпечної обробки null-значень, таких як `?.`, `?:`, `!!`. Це робить код більш безпечним і зменшує кількість винятків через NullPointerException.",
              "Загалом, Kotlin намагається спростити та покращити обробку помилок порівняно з Java, роблячи код менш вразливим до неконтрольованих винятків."
            ]
          }
        ]
      }
    ]
  }
]
